Binary files Professor-2.2.2/build/lib.linux-x86_64-2.7/professor2/core.so and Professor-2.2.2_mod/build/lib.linux-x86_64-2.7/professor2/core.so differ
diff -uNr Professor-2.2.2/build/lib.linux-x86_64-2.7/professor2/ipol.py Professor-2.2.2_mod/build/lib.linux-x86_64-2.7/professor2/ipol.py
--- Professor-2.2.2/build/lib.linux-x86_64-2.7/professor2/ipol.py	2017-11-13 15:32:46.000000000 +0100
+++ Professor-2.2.2_mod/build/lib.linux-x86_64-2.7/professor2/ipol.py	2018-01-05 15:38:09.000000000 +0100
@@ -22,7 +22,7 @@
     return runs, paramnames, paramslist
 
 
-def mk_ipolbin(rawP, rawV, rawE, xmin, xmax, CFG):
+def mk_ipolbin(rawP, rawV, rawE, xmin, xmax, CFG, n = 0, hn = ""):
     # TODO finally learn how to use kwargs
     order    = CFG["ORDER"]
     errorder = CFG["ERR_ORDER"]
@@ -53,6 +53,13 @@
 
     if order == "auto":
         valipol =mk_autoipol(P, V, CFG)
+    elif order < 0:
+        valipol = Ipol(P, V, int(order), E, n, hn, True, 0, [0], "")
+        if errorder == -1:
+            erripols = Ipol(P, V, int(order), E, n, hn, False, valipol.order(), valipol.coeffs(), "")
+            return IpolBin(xmin, xmax, valipol, erripols), pmin, pmax
+        else:
+			errororder = valipol.order()
     else:
         valipol = Ipol(P, V, int(order))
 
@@ -249,7 +256,7 @@
                     CFG["ERR_ORDER"]=temp[3]
                     ib, pmin, pmax = prof.mk_ipolbin(PARAMSLIST, vals, errs, xmin, xmax, CFG)
                 else:
-                    ib, pmin, pmax = prof.mk_ipolbin(PARAMSLIST, vals, errs, xmin, xmax, CFG)
+                    ib, pmin, pmax = prof.mk_ipolbin(PARAMSLIST, vals, errs, xmin, xmax, CFG, n, hn)
                 s = ""
                 s += "%s#%d %.5e %.5e\n" % (hn, n, ib.xmin, ib.xmax)
                 s += "  " + ib.ival.toString("val")
Binary files Professor-2.2.2/build/temp.linux-x86_64-2.7/pyext/professor2/core.o and Professor-2.2.2_mod/build/temp.linux-x86_64-2.7/pyext/professor2/core.o differ
diff -uNr Professor-2.2.2/include/Professor/ConfigHandler.h Professor-2.2.2_mod/include/Professor/ConfigHandler.h
--- Professor-2.2.2/include/Professor/ConfigHandler.h	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/include/Professor/ConfigHandler.h	2017-11-30 13:15:24.485008000 +0100
@@ -0,0 +1,54 @@
+#ifndef __CONFIGHANDLER__H
+#define __CONFIGHANDLER__H
+
+#include <iostream>
+#include <fstream>
+#include <string>
+
+using namespace std;
+
+/**
+* This class handles a config file provided by the user.
+* It handles the reading of the file and stores all necessary information in the object.
+*/
+class ConfigHandler
+{
+public:
+	//Constructor
+	ConfigHandler(const string configfile);
+
+	//getter of member variables
+	const bool getSummaryFlag(){return _summaryflag;}
+	const bool getOutDotFlag(){return _outdotflag;}
+	const bool getCovmatFlag(){return _covmat;}
+	const double getThresholdFit(){return _thresholdfit;}
+	const double getThresholdData(){return _thresholddata;}
+	const double getThresholdErr(){return _thresholderr;}
+	const double getChi2Mean(){return _chi2mean;}
+	const double getKappa(){return _kappa;}
+
+private:
+	//setter for the member variables
+	void readThresholdFit(const string line);
+	void readThresholdData(const string line);
+	void readThresholdErr(const string line);
+	void readChi2Mean(const string line);
+	void readKappa(const string line);
+	void readSummaryFlag(const string line);
+	void readOutDotFlag(const string line);
+	void readCovMat(const string line);
+
+	/**
+	* @_summaryflag, @_outdotflag: flags for writing additional summaries
+	* @_covmat: flag for writing covariance matrices
+	* @_thresholdfit: threshold of the RR constrain in the fitting
+	* @_thresholddata: threshold of the RR constrain in the hypercube-fitting of the data
+	* @_thresholderr: threshold of the RR constrain in getter of the fitting errors
+	* @_chi2mean: number of modified chi2's to store in order to state a best value regarding the modified chi2
+	* @_kappa: shifting parameter if the RR constrain is applied
+	*/
+	bool _summaryflag = true, _outdotflag = false, _covmat = true;
+	double _thresholdfit = 1e-10, _thresholddata = 1e-10, _thresholderr = 1e-10, _chi2mean = 100, _kappa = 1e-10;
+};
+
+#endif
diff -uNr Professor-2.2.2/include/Professor/Counter.h Professor-2.2.2_mod/include/Professor/Counter.h
--- Professor-2.2.2/include/Professor/Counter.h	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/include/Professor/Counter.h	2017-11-27 14:20:50.109927000 +0100
@@ -0,0 +1,44 @@
+#ifndef __COUNTER__H
+#define __COUNTER__H
+
+#include <vector>
+
+//This code is copied from Professor 2.1.3
+//Source: prof2 -> counter.h / counter.cc / Ipol.cc->mkStructure()
+using namespace std;
+
+/**
+ * This class creates the powers for the parameters in the monomials.
+ */
+class Counter {
+public:
+
+    /**
+     * This constructor sets up the member variables
+     * @dim: this parameter represents the dimension of the parameters
+     * @maxval: this is the order of the monomial
+     */
+    Counter(const size_t dim, const int maxval) {
+      for (unsigned int i = 0; i < dim; ++i) _data.push_back(0);
+      _maxval = maxval;
+    };
+    
+    //Destructor
+    ~Counter(void);
+
+	//calculating another step in order to get the powers of a monomial
+    const bool next(const int index);
+
+	//sums up the powers
+    const int sum() const;
+
+	//getter of the powers
+    const vector<int> data() const {return _data;}
+
+private:
+	//@_maxval stores the information about the order
+	//@_data stores the powers
+    int _maxval;
+    vector<int> _data;
+};
+#endif
diff -uNr Professor-2.2.2/include/Professor/FitHandler.h Professor-2.2.2_mod/include/Professor/FitHandler.h
--- Professor-2.2.2/include/Professor/FitHandler.h	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/include/Professor/FitHandler.h	2017-11-30 11:41:06.133012000 +0100
@@ -0,0 +1,88 @@
+#ifndef __FITHANDLER__H
+#define __FITHANDLER__H
+
+#include <iostream>
+#include <vector>
+#include <math.h>
+#include "Professor/LinAlg.h"
+#include "Professor/OutputHandler.h"
+#include "Professor/ParamPoints.h"
+#include <Eigen/Dense>
+#include "Professor/QRHandler.h"
+
+using namespace std;
+using namespace Eigen;
+
+/**
+* This class handles the fitting procedure.
+*/
+class FitHandler
+{
+
+public:
+	//Default Constructor for fitting
+	FitHandler();
+
+	//Constructor used for uncertainty calculation
+	FitHandler(const vector<double>& fitparams, const vector<double>& pterrs, Professor::ParamPoints& pts, const int order, const int num_ipol, const string histname);
+
+	//calculates the next iterationstep
+	void nextStep(Professor::ParamPoints& pts, const double threshold, const double kappa);
+
+	//calculator of fit uncertainties
+	void setFitErrors(const size_t num_ipol, const string histname);
+
+	//getter of the smoothness
+	const double getDsmooth(Professor::ParamPoints& pts);
+
+	//getter of Chi2
+	const double getChi2() const;
+
+	//init of a new bin
+	void startBin(Professor::ParamPoints& pts, const vector<double>& ptvals, const vector<double>& pterrs, const double threshold, const double kappa);
+
+	//getter of the number of fitparameters
+	const size_t getNumFitParams() const;
+
+	//setter of a specific bin in a specific iterationstep
+	void setToIteration(Professor::ParamPoints& pts, const vector<double>& ptvals, const vector<double>& pterrs, const int num_ipol, const double threshold, const double kappa, const int bestiteration);
+
+	//calculates the dot product between every gradient vector
+	const vector<double> getAllGradDotProducts(Professor::ParamPoints& pts);
+
+	//adds 0's as fit parameters and changes the order of the fit parameters in order to become usable in Professor 2.2.1
+	void sortFitParams(const vector<int>& match_index);
+
+	//Getter
+	const int getMaxPower() const {return _qrh.getMaxPower();}
+	const vector<double>& getFitErrors() const {return _bfperr;}
+	const vector<vector<int>>& getPowers() const {return _qrh.getPower();}
+	const size_t getIterationCounter() const {return _qrh.getIterationCounter();}
+	const vector<double>& get_a() const {return _a;}
+	const vector<double>& getFitParams() const {return _bfp;}
+
+private:
+	/**
+	* @_a: vector for the fitparameters; is used as indicator of RR constrained parameters
+	* @_d: identity matrix
+	* @_bfp, @_bfperr: best fit parameters and corresponding errors
+	* @_sigma: error of the reference values
+	* @_dsmooth_current: Storage of the dsmooth value in a certain step in order to avoid recalculation. The default value indicates an unset value.
+	* @_qrh: Object that handles the linear algebra tasks in the iterations
+	* @_gc: Object that handles the gradient calculation
+	*/
+	vector<double> _a, _d, _bfp, _bfperr, _sigma;
+	double _dsmooth_current = 2;
+	QRHandler _qrh;
+	GradCalc _gc;
+
+	//rescaling @_bfp because of the normalization
+	void rescaleBestFitParameters();
+
+	//getter of a single element of the precision matrix
+	const double getInvCovMatElement(const size_t i, const size_t j) const;
+	
+};
+
+#endif
+
diff -uNr Professor-2.2.2/include/Professor/GradCalc.h Professor-2.2.2_mod/include/Professor/GradCalc.h
--- Professor-2.2.2/include/Professor/GradCalc.h	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/include/Professor/GradCalc.h	2017-11-27 15:39:54.731305000 +0100
@@ -0,0 +1,44 @@
+#ifndef __GRADCALC__H
+#define __GRADCALC__H
+
+#include <vector>
+#include "Professor/LinAlg.h"
+#include "Professor/ParamPoints.h"
+
+using namespace std;
+
+namespace Professor{class ParamPoints;}
+
+/**
+ * This objects calculates gradient vectors of a polynomial function
+ */
+class GradCalc
+{
+public:
+	//Constructor
+	GradCalc(){}
+
+	//Resize @_structure
+	void initStructure(const Professor::ParamPoints& pts);
+	
+	//Getter of the the @i-th gradient vector
+	const vector<double> getGradVector(const size_t i, const std::vector<double>& bfp, Professor::ParamPoints& pts, const int order);
+	
+	//Getter of all gradient vectors
+	const vector<vector<double>> getAllGradVectors(const std::vector<double>& bfp, Professor::ParamPoints& pts, const int order);
+
+private:
+
+	//Add terms to @_structure
+	void extendStructure(const size_t i, const size_t j, const size_t numFitParams, Professor::ParamPoints& pts, const int order);
+	
+	//Adds a monomial to @_structure
+	const double addMonomial(const size_t i, const size_t j, const size_t k, Professor::ParamPoints& pts, const int order);
+	
+	//Setter of @_structure
+	void setStructure(const size_t i, const size_t j, const vector<double> vec){_structure[i][j] = vec;}
+
+	//List of the fit parameter independent part of the gradient vectors. Structure: [number of anchor points][dimension][monomial]
+	vector<vector<vector<double>>> _structure;
+};
+#endif
diff -uNr Professor-2.2.2/include/Professor/HyperCubeIpol.h Professor-2.2.2_mod/include/Professor/HyperCubeIpol.h
--- Professor-2.2.2/include/Professor/HyperCubeIpol.h	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/include/Professor/HyperCubeIpol.h	2017-11-27 14:48:54.420153000 +0100
@@ -0,0 +1,48 @@
+#ifndef __HYPERCUBEIPOL__H
+#define __HYPERCUBEIPOL__H
+
+#include <vector>
+#include "Professor/LinAlg.h"
+#include "Professor/ParamPoints.h"
+#include "Professor/QRHandler.h"
+
+using namespace std;
+
+/**
+ * This class handles the selection of anchor points for a hypercube around a given point and calculates a polynomial fit of 1st order through all points.
+ */
+class HyperCubeIpol
+{
+public:
+	//Constructor
+	HyperCubeIpol();
+
+	//Getter of the indices referring to a hypercube surrounding a point with index @i
+	const vector<size_t>& gethypercube(const size_t i, const vector<vector<double>>& pts);
+
+	//Getter of @_hypercubes
+	const vector<vector<size_t>>& hypercubes() {return _hypercubes;}
+	
+	//Getter of the fit parameters of all anchor points
+	const vector<vector<double>>& getAllFitParams(const vector<vector<double>>& pts, const vector<double>& ptvals);
+	
+	//Getter of the fit parameter for the @i-th anchor point
+	const vector<double>& getFitParams(const size_t i, const vector<vector<double>>& pts, const vector<double>& ptvals);
+	
+private:
+
+	//Construction of a hypercube around the @i-th anchor point
+	void buildHyperCube(const size_t i, const vector<vector<double>>& pts);
+	
+	//Calculator of the fit parameters for the @i-th anchor point
+	void calcFitParams(const size_t i, const vector<vector<double>>& pts, const vector<double>& ptvals);
+
+	//list of indices for hypercubes of the anchor points
+	vector<vector<size_t>> _hypercubes;
+	
+	//list of fit parameters of the anchro points
+	vector<vector<double>> _fitparams;
+};
+
+#endif
+
diff -uNr Professor-2.2.2/include/Professor/Ipol.h Professor-2.2.2_mod/include/Professor/Ipol.h
--- Professor-2.2.2/include/Professor/Ipol.h	2017-11-13 15:32:46.000000000 +0100
+++ Professor-2.2.2_mod/include/Professor/Ipol.h	2018-01-05 14:54:19.855775081 +0100
@@ -7,6 +7,11 @@
 #include <sstream>
 #include <iostream>
 #include <stdexcept>
+#include "Professor/ConfigHandler.h"
+#include "Professor/OutputHandler.h"
+#include "Professor/FitHandler.h"
+
+class FitHandler;
 
 namespace Professor {
 
@@ -101,6 +106,9 @@
       _coeffs = calcCoeffs(pts, ptvals, _order, svdthreshold, _structure);
     };
 
+    //modified constructor for the iterative fitting
+    Ipol(ParamPoints& pts, const std::vector<double>& ptvals, const vector<double>& pterrs, const int num_ipol, const string histname, const bool doipol, const int order, const std::vector<double>& fitparams, const string configfile);
+
     /// Constructor to read ipol from file (one string for each object)
     /// @todo Also allow optional passing of pmins, pmaxs vectors for the case where the string includes scaling?
     Ipol(const std::string& s) {
@@ -208,6 +216,27 @@
     std::string _name;
     std::vector<double> _coeffs, _minPV, _maxPV;
 
+	//Structure that stores parameters that state the fit quality. This is necessary for a cut-off of the iterations
+	struct qualityparams{
+		size_t bestiteration;
+		double bestF;
+		vector<double> Fvalues;
+	};
+	
+	//Setter of parameters that are needed by Professor
+	void setparams(ParamPoints& pts, FitHandler& fh);
+	
+	//Function that performs an iteration of the adaptive interpolation
+	const bool iterate(FitHandler& fh, ParamPoints& pts, ConfigHandler* const ch, qualityparams& qp) const;
+	
+    //mapping function of the fit parameter terms in order to use them with Professor 2.2.1
+    const std::vector<int> sort_strucs(ParamPoints& pts) const;
+    
+    //function that actually performs the fit
+    void calcipol(ParamPoints& pts, const std::vector<double>& ptvals, const std::vector<double>& pterrs, const int num_ipol, const std::string configfile, const std::string histname);
+
+    //function that actually performs the error calculation of the fit
+    void calcerr(ParamPoints& pts, const std::vector<double>& pterrs, const int order, const std::vector<double>& fitparams, const int num_ipol, const std::string histname);
   };
 
 
diff -uNr Professor-2.2.2/include/Professor/LinAlg.h Professor-2.2.2_mod/include/Professor/LinAlg.h
--- Professor-2.2.2/include/Professor/LinAlg.h	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/include/Professor/LinAlg.h	2017-11-28 12:45:24.322795000 +0100
@@ -0,0 +1,49 @@
+#ifndef __LINALG__H
+#define __LINALG__H
+
+#include <vector>
+#include <math.h>
+
+using namespace std;
+
+/**
+* This Class is a container of functions related to linear algebra.
+*/
+class LinAlg
+{
+public:
+
+	//extracts a column from a matrix
+	static const vector<double> getCol(const vector<vector<double>>& mat, const size_t j);
+
+	//calculates the absolut value of a vector
+	static const double getAbs(const vector<double>& vec);
+
+	//transposes a matrix
+	static const vector<vector<double>> transpose(const vector<vector<double>>& mat);
+
+	//multiplies a matrix and a vector
+	static const vector<double> multMatVec(const vector<vector<double>>& mat, const vector<double>& vec);
+
+	//normalizes a vector
+	static const vector<double> normalizeVec(const vector<double>& vec);
+
+	//calculates the difference between two vectors
+	static const double getDistanceOfVectors(vector<double> a, const vector<double>& b);
+
+	//calculates the dotproduct of two vectors
+	static const double dotProduct(const vector<double>& a, const vector<double>& b);
+
+	//solves a problem of the type matrix * vector = vector
+	static const vector<double> getBestFitParameters(const vector<vector<double>>& a, const vector<double>& x, vector<double> b);
+
+	//checks if diagonal terms of @r are too small and regulates the resulting fit
+	static void collinearity(vector<double>& a, const vector<vector<double>>& r, const vector<double>& b, const double threshold, const double kappa);
+	
+private:
+
+	//Constructor
+	LinAlg(){}
+};
+
+#endif
diff -uNr Professor-2.2.2/include/Professor/OutputHandler.h Professor-2.2.2_mod/include/Professor/OutputHandler.h
--- Professor-2.2.2/include/Professor/OutputHandler.h	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/include/Professor/OutputHandler.h	2017-11-30 11:38:58.055911000 +0100
@@ -0,0 +1,56 @@
+#ifndef __OUTPUTHANDLER__H
+#define __OUTPUTHANDLER__H
+
+#include <iostream>
+#include <vector>
+#include <fstream>
+#include "Professor/LinAlg.h"
+#include "Professor/ParamPoints.h"
+#include "Professor/FitHandler.h"
+#include <Eigen/Dense>
+
+using namespace std;
+using namespace Eigen;
+
+class FitHandler;
+
+/**
+* This Class is a container for output functions
+*/
+class OutputHandler
+{
+public:
+
+	//Default constructor 
+	OutputHandler();
+	
+	//Constructor that sets up some necessary parameters
+	OutputHandler(const Professor::ParamPoints& pts, const bool outdotflag, const bool summaryflag, const size_t& num_ipol);
+	
+	//writes a summary of the fit to the terminal
+	void writeBinResult(const size_t num_ipol, Professor::ParamPoints& pts, FitHandler& fh) const;
+
+	//writes a dotproduct-summary
+	void writeDotProduct(const size_t num_ipol, Professor::ParamPoints& pts, FitHandler& fh) const;
+
+	//writes to the summaryfile
+	void writeSummary(FitHandler& fh, Professor::ParamPoints& pts) const;
+	
+	//setup of the summary file
+	void setupSummary() const;
+
+	//writes a covariance matrix to file
+	void writeCovMat(const MatrixXd& mat, const size_t num_ipol, const string histname) const;
+
+private:
+
+	/**
+	 * @distances: distances of every anchor point to another
+	 */
+	vector<double> _distances;
+	
+	//calculates the distances between the anchor points
+	void setDistances(const Professor::ParamPoints& pts);
+};
+
+#endif
diff -uNr Professor-2.2.2/include/Professor/ParamPoints.h Professor-2.2.2_mod/include/Professor/ParamPoints.h
--- Professor-2.2.2/include/Professor/ParamPoints.h	2017-11-13 15:32:46.000000000 +0100
+++ Professor-2.2.2_mod/include/Professor/ParamPoints.h	2018-01-05 14:58:29.318146147 +0100
@@ -7,6 +7,9 @@
 #include <vector>
 #include <cassert>
 #include <stdexcept>
+#include "Professor/Power.h"
+#include "Professor/HyperCubeIpol.h"
+#include "Professor/GradCalc.h"
 
 namespace Professor {
 
@@ -129,13 +132,39 @@
     const std::vector<double>& point(size_t i) const { return points().at(i); }
 
 
+    // This function rescales @_parampoints and stores them in @_parampoints_scaled
+    void rescale();
+	
+	//deletes all information that are not necessary to store after the fitting
+    void clearAll();
+
+    	//Getter
+    	const std::vector<std::vector<int>> getPower(const int order) {return _pow.getPowerOfOrder(order);}
+    	const Power& getPow() const {return _pow;}
+    	const std::vector<std::vector<double>>& pointsScaled() const { return _parampoints_scaled;}
+    	const std::vector<double>& pointScaled(const size_t i) const { return pointsScaled().at(i); }
+	const vector<double>& getGradient(const size_t i) {return _gradients[i];}
+	const vector<double> getAllGradDotProducts() const;
+	
+	//Setter
+	void setpointsScaled(const std::vector<std::vector<double>>& vec) {_parampoints_scaled = vec;}
+	void setGradients(const std::vector<double> ptvals);
+	
   private:
 
-    std::vector< std::vector<double> > _parampoints;
+	/**
+	 * @_parampoints: anchor points
+	 * @_parampoints_scaled: scaled @_parampoints onto [0,1]-interval
+	 * @_gradients: gradient vectors at @_parampoints
+	 */
+    std::vector< std::vector<double> > _parampoints, _parampoints_scaled, _gradients;
 
     std::vector< std::string > _names;
 
     bool _locked;
+    
+    // Helper class to retrieve the list of powers
+    Power _pow;
 
   };
 
diff -uNr Professor-2.2.2/include/Professor/Power.h Professor-2.2.2_mod/include/Professor/Power.h
--- Professor-2.2.2/include/Professor/Power.h	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/include/Professor/Power.h	2017-11-27 15:14:02.858253000 +0100
@@ -0,0 +1,38 @@
+#ifndef __POWER__H
+#define __POWER__H
+
+#include <vector>
+#include "Professor/Counter.h"
+
+using namespace std;
+
+/**
+ * This class serves as a lookup table for the list of powers of a certain order
+ */
+class Power {
+public:
+   	//Constructor
+	Power() {};
+
+	//getter for the list of powers of a certain order
+	const vector<vector<int>> getPowerOfOrder(const int order);
+
+	//Setter of the dimension
+   	void setDim(const size_t size) {n = size;}
+
+	//delete @_powerlist
+	void clearAll() {_powerlist.clear();}
+	
+private:
+
+	//setter for the list of powers of a new order
+	void setPowerOfOrder(const int order);
+
+	//list of lists of powers of certain orders; Structure: [polynomial order][monomial][power of the parameter]
+	vector<vector<vector<int>>> _powerlist;
+	
+	//dimension of the polynom
+	size_t n;
+
+};
+#endif
diff -uNr Professor-2.2.2/include/Professor/QRHandler.h Professor-2.2.2_mod/include/Professor/QRHandler.h
--- Professor-2.2.2/include/Professor/QRHandler.h	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/include/Professor/QRHandler.h	2017-11-28 12:45:23.086823000 +0100
@@ -0,0 +1,86 @@
+#ifndef __QRHANDLER__H
+#define __QRHANDLER__H
+
+#include <iostream>
+#include <vector>
+#include "Professor/LinAlg.h"
+#include <limits>
+#include "Professor/ParamPoints.h"
+#include <cmath>
+
+using namespace std;
+namespace Professor{class ParamPoints;};
+
+/**
+ * This class handles the matrix M and the vector b of a problem of the type M*x=b by performing a Gram-Schmidt-QR-decomposition.
+ */
+class QRHandler
+{
+
+public:
+
+	//Constructor
+	QRHandler(){}
+
+	//Setup and store information
+	void init(Professor::ParamPoints& pts, const vector<double>& ptvals);
+	
+	//Performs an iteration
+	void iterate(Professor::ParamPoints& pts, bool walkthrough = false);
+	
+	//Sets the object to given iteration number
+	void load(int order, Professor::ParamPoints& pts, const size_t numFitParams);
+	
+	//Deletes stored information
+	void reset();
+
+	//Getter
+	const vector<vector<double>>& getM() const {return _m;}
+	const vector<vector<double>>& getR() const {return _r;}
+	const vector<double>& getBprime() const {return _bprime;}
+	const vector<double>& getB() const {return _b;}
+	const int getMaxPower() const {return _max;}
+	const size_t getIterationCounter() const {return _iterationcounter;}
+	const vector<vector<int>>& getPower() const {return _power;}
+
+private:
+	/**
+	 * @_m: storage of the matrix M
+	 * @_q, @r: storage of the matrices Q & R of the QR-decomposition
+	 * @_mprime: columnwise normalized M
+	 * @_b: reference values
+	 * @_bprime: normalized @_b
+	 * @_power: list that contains the powers of the variables at the terms of the fitting function
+	 * @_max: maximum of powers
+	 * @_iterationcounter: number of iterations in the fitting process
+	 */
+	vector<vector<double>> _m, _q, _r, _mprime;
+	vector<double> _b, _bprime;
+	vector<vector<int>> _power;
+	int _max; 
+	size_t _iterationcounter;
+
+	//Initializer of @_q and @_r
+	const bool initQR();
+	
+	//Performs an iteration of @_m
+	void iterateM(Professor::ParamPoints& pts);
+	
+	//Performs and iteration of @_b
+	void iterateb();
+	
+	//Updates the sizes of @_q and @_r
+	void resizeQR();
+
+	//Adds components to @_q and @_r
+	void expandQR();
+
+	//Calculates @_mprime from @_m
+	void makeMprime();
+
+	//Adds elements to @_m
+	void increaseM(Professor::ParamPoints& pts);	
+};
+
+#endif
+
Binary files Professor-2.2.2/lib/libProfessor2.so and Professor-2.2.2_mod/lib/libProfessor2.so differ
Binary files Professor-2.2.2/lib/python2.7/site-packages/professor2/core.so and Professor-2.2.2_mod/lib/python2.7/site-packages/professor2/core.so differ
diff -uNr Professor-2.2.2/lib/python2.7/site-packages/professor2/ipol.py Professor-2.2.2_mod/lib/python2.7/site-packages/professor2/ipol.py
--- Professor-2.2.2/lib/python2.7/site-packages/professor2/ipol.py	2017-11-13 15:32:46.000000000 +0100
+++ Professor-2.2.2_mod/lib/python2.7/site-packages/professor2/ipol.py	2018-01-05 15:38:09.000000000 +0100
@@ -22,7 +22,7 @@
     return runs, paramnames, paramslist
 
 
-def mk_ipolbin(rawP, rawV, rawE, xmin, xmax, CFG):
+def mk_ipolbin(rawP, rawV, rawE, xmin, xmax, CFG, n = 0, hn = ""):
     # TODO finally learn how to use kwargs
     order    = CFG["ORDER"]
     errorder = CFG["ERR_ORDER"]
@@ -53,6 +53,13 @@
 
     if order == "auto":
         valipol =mk_autoipol(P, V, CFG)
+    elif order < 0:
+        valipol = Ipol(P, V, int(order), E, n, hn, True, 0, [0], "")
+        if errorder == -1:
+            erripols = Ipol(P, V, int(order), E, n, hn, False, valipol.order(), valipol.coeffs(), "")
+            return IpolBin(xmin, xmax, valipol, erripols), pmin, pmax
+        else:
+			errororder = valipol.order()
     else:
         valipol = Ipol(P, V, int(order))
 
@@ -249,7 +256,7 @@
                     CFG["ERR_ORDER"]=temp[3]
                     ib, pmin, pmax = prof.mk_ipolbin(PARAMSLIST, vals, errs, xmin, xmax, CFG)
                 else:
-                    ib, pmin, pmax = prof.mk_ipolbin(PARAMSLIST, vals, errs, xmin, xmax, CFG)
+                    ib, pmin, pmax = prof.mk_ipolbin(PARAMSLIST, vals, errs, xmin, xmax, CFG, n, hn)
                 s = ""
                 s += "%s#%d %.5e %.5e\n" % (hn, n, ib.xmin, ib.xmax)
                 s += "  " + ib.ival.toString("val")
Binary files Professor-2.2.2/lib/python2.7/site-packages/professor2/ipol.pyc and Professor-2.2.2_mod/lib/python2.7/site-packages/professor2/ipol.pyc differ
diff -uNr Professor-2.2.2/Makefile Professor-2.2.2_mod/Makefile
--- Professor-2.2.2/Makefile	2017-11-13 15:32:46.000000000 +0100
+++ Professor-2.2.2_mod/Makefile	2018-01-05 15:22:29.881597402 +0100
@@ -83,7 +83,7 @@
 
 LIBHEADERS := $(wildcard include/Professor/*.h)
 LIBSOURCES := $(wildcard src/*.cc)
-LIBOBJECTS := $(patsubst %,obj/%.o, ParamPoints Ipol Version)
+LIBOBJECTS := $(patsubst %,obj/%.o, ParamPoints Ipol Version FitHandler ConfigHandler OutputHandler LinAlg Power Counter GradCalc HyperCubeIpol QRHandler)
 TESTSOURCES := $(wildcard test/*.cc test/testPython*)
 TESTPROGS  := test/testParamPoints test/testIpol
 BINPROGS := $(wildcard bin/*)
Binary files Professor-2.2.2/obj/ConfigHandler.o and Professor-2.2.2_mod/obj/ConfigHandler.o differ
Binary files Professor-2.2.2/obj/Counter.o and Professor-2.2.2_mod/obj/Counter.o differ
Binary files Professor-2.2.2/obj/FitHandler.o and Professor-2.2.2_mod/obj/FitHandler.o differ
Binary files Professor-2.2.2/obj/GradCalc.o and Professor-2.2.2_mod/obj/GradCalc.o differ
Binary files Professor-2.2.2/obj/HyperCubeIpol.o and Professor-2.2.2_mod/obj/HyperCubeIpol.o differ
Binary files Professor-2.2.2/obj/Ipol.o and Professor-2.2.2_mod/obj/Ipol.o differ
Binary files Professor-2.2.2/obj/LinAlg.o and Professor-2.2.2_mod/obj/LinAlg.o differ
Binary files Professor-2.2.2/obj/OutputHandler.o and Professor-2.2.2_mod/obj/OutputHandler.o differ
Binary files Professor-2.2.2/obj/ParamPoints.o and Professor-2.2.2_mod/obj/ParamPoints.o differ
Binary files Professor-2.2.2/obj/Power.o and Professor-2.2.2_mod/obj/Power.o differ
Binary files Professor-2.2.2/obj/QRHandler.o and Professor-2.2.2_mod/obj/QRHandler.o differ
diff -uNr Professor-2.2.2/pyext/professor2/core.cpp Professor-2.2.2_mod/pyext/professor2/core.cpp
--- Professor-2.2.2/pyext/professor2/core.cpp	2018-01-05 15:47:00.240320666 +0100
+++ Professor-2.2.2_mod/pyext/professor2/core.cpp	2018-01-05 15:22:54.445041972 +0100
@@ -871,6 +871,7 @@
 static PyObject *__pyx_pf_10professor2_4core_4Ipol_36__repr__(struct __pyx_obj_10professor2_4core_Ipol *__pyx_v_self); /* proto */
 static PyObject *__pyx_tp_new_10professor2_4core_ParamPoints(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_10professor2_4core_Ipol(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static PyObject *__pyx_int_0;
 static PyObject *__pyx_tuple__2;
 static PyObject *__pyx_tuple__4;
 static PyObject *__pyx_tuple__6;
@@ -1364,6 +1365,12 @@
   struct __pyx_obj_10professor2_4core_ParamPoints *__pyx_v_pp = NULL;
   PyObject *__pyx_v_vals = NULL;
   PyObject *__pyx_v_order = NULL;
+  PyObject *__pyx_v_errs = NULL;
+  PyObject *__pyx_v_bin_num = NULL;
+  PyObject *__pyx_v_histname = NULL;
+  PyObject *__pyx_v_doipol = NULL;
+  PyObject *__pyx_v_fitparams = NULL;
+  PyObject *__pyx_v_config = NULL;
   PyObject *__pyx_v_name = NULL;
   double __pyx_v_threshold;
   int __pyx_r;
@@ -1376,15 +1383,20 @@
   std::string __pyx_t_6;
   Professor::Ipol *__pyx_t_7;
   PyObject *__pyx_t_8 = NULL;
-  PyObject *__pyx_t_9 = NULL;
-  PyObject *__pyx_t_10 = NULL;
-  PyObject *__pyx_t_11 = NULL;
-  double __pyx_t_12;
-  PyObject *__pyx_t_13 = NULL;
-  PyObject *__pyx_t_14 = NULL;
-  PyObject *__pyx_t_15 = NULL;
-  std::vector<double>  __pyx_t_16;
-  int __pyx_t_17;
+  std::vector<double>  __pyx_t_9;
+  std::vector<double>  __pyx_t_10;
+  int __pyx_t_11;
+  bool __pyx_t_12;
+  int __pyx_t_13;
+  std::vector<double>  __pyx_t_14;
+  std::string __pyx_t_15;
+  PyObject *__pyx_t_16 = NULL;
+  PyObject *__pyx_t_17 = NULL;
+  PyObject *__pyx_t_18 = NULL;
+  double __pyx_t_19;
+  PyObject *__pyx_t_20 = NULL;
+  PyObject *__pyx_t_21 = NULL;
+  PyObject *__pyx_t_22 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
@@ -1468,7 +1480,7 @@
  *             pp = ParamPoints(args[0])
  *             vals = list(args[1])             # <<<<<<<<<<<<<<
  *             order = int(args[2])
- *             name = ""
+ *             if order < 0:
  */
     __pyx_t_4 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_4 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
     __Pyx_GOTREF(__pyx_t_4);
@@ -1482,8 +1494,8 @@
  *             pp = ParamPoints(args[0])
  *             vals = list(args[1])
  *             order = int(args[2])             # <<<<<<<<<<<<<<
- *             name = ""
- *             threshold = 1e-40 #< ???
+ *             if order < 0:
+ *                 errs = list(args[3])
  */
     __pyx_t_8 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_8 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 52; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
     __Pyx_GOTREF(__pyx_t_8);
@@ -1496,215 +1508,379 @@
     /* "professor2/core.pyx":53
  *             vals = list(args[1])
  *             order = int(args[2])
- *             name = ""             # <<<<<<<<<<<<<<
- *             threshold = 1e-40 #< ???
- *             if len(args) == 4:
+ *             if order < 0:             # <<<<<<<<<<<<<<
+ *                 errs = list(args[3])
+ *                 bin_num = int(args[4])
  */
-    __Pyx_INCREF(__pyx_kp_s__3);
-    __pyx_v_name = __pyx_kp_s__3;
+    __pyx_t_4 = PyObject_RichCompare(__pyx_v_order, __pyx_int_0, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 53; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    if (__pyx_t_1) {
 
-    /* "professor2/core.pyx":54
+      /* "professor2/core.pyx":54
  *             order = int(args[2])
- *             name = ""
- *             threshold = 1e-40 #< ???             # <<<<<<<<<<<<<<
- *             if len(args) == 4:
- *                 try:
- */
-    __pyx_v_threshold = 1e-40;
-
-    /* "professor2/core.pyx":55
- *             name = ""
- *             threshold = 1e-40 #< ???
- *             if len(args) == 4:             # <<<<<<<<<<<<<<
- *                 try:
- *                     threshold = float(args[3])
+ *             if order < 0:
+ *                 errs = list(args[3])             # <<<<<<<<<<<<<<
+ *                 bin_num = int(args[4])
+ *                 histname = str(args[5])
  */
-    __pyx_t_2 = PyTuple_GET_SIZE(__pyx_v_args); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_1 = ((__pyx_t_2 == 4) != 0);
-    if (__pyx_t_1) {
+      __pyx_t_4 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_4 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_8 = PySequence_List(__pyx_t_4); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_v_errs = ((PyObject*)__pyx_t_8);
+      __pyx_t_8 = 0;
+
+      /* "professor2/core.pyx":55
+ *             if order < 0:
+ *                 errs = list(args[3])
+ *                 bin_num = int(args[4])             # <<<<<<<<<<<<<<
+ *                 histname = str(args[5])
+ *                 doipol = bool(args[6])
+ */
+      __pyx_t_8 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 4, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_8 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+      __Pyx_GOTREF(__pyx_t_8);
+      __pyx_t_4 = PyNumber_Int(__pyx_t_8); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __pyx_v_bin_num = __pyx_t_4;
+      __pyx_t_4 = 0;
 
       /* "professor2/core.pyx":56
- *             threshold = 1e-40 #< ???
- *             if len(args) == 4:
- *                 try:             # <<<<<<<<<<<<<<
- *                     threshold = float(args[3])
- *                 except:
- */
-      {
-        __Pyx_ExceptionSave(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
-        __Pyx_XGOTREF(__pyx_t_9);
-        __Pyx_XGOTREF(__pyx_t_10);
-        __Pyx_XGOTREF(__pyx_t_11);
-        /*try:*/ {
-
-          /* "professor2/core.pyx":57
- *             if len(args) == 4:
- *                 try:
- *                     threshold = float(args[3])             # <<<<<<<<<<<<<<
- *                 except:
- *                     name = str(args[3])
+ *                 errs = list(args[3])
+ *                 bin_num = int(args[4])
+ *                 histname = str(args[5])             # <<<<<<<<<<<<<<
+ *                 doipol = bool(args[6])
+ *                 order = int(args[7])
  */
-          __pyx_t_4 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_4 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L7_error;};
-          __Pyx_GOTREF(__pyx_t_4);
-          __pyx_t_12 = __Pyx_PyObject_AsDouble(__pyx_t_4); if (unlikely(__pyx_t_12 == ((double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L7_error;}
-          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-          __pyx_v_threshold = __pyx_t_12;
-
-          /* "professor2/core.pyx":56
- *             threshold = 1e-40 #< ???
- *             if len(args) == 4:
- *                 try:             # <<<<<<<<<<<<<<
- *                     threshold = float(args[3])
- *                 except:
+      __pyx_t_4 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 5, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_4 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_GIVEREF(__pyx_t_4);
+      PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __pyx_v_histname = __pyx_t_4;
+      __pyx_t_4 = 0;
+
+      /* "professor2/core.pyx":57
+ *                 bin_num = int(args[4])
+ *                 histname = str(args[5])
+ *                 doipol = bool(args[6])             # <<<<<<<<<<<<<<
+ *                 order = int(args[7])
+ *                 fitparams = list(args[8])
  */
-        }
-        __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
-        __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
-        __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-        goto __pyx_L14_try_end;
-        __pyx_L7_error:;
-        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
-        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-        /* "professor2/core.pyx":58
- *                 try:
- *                     threshold = float(args[3])
- *                 except:             # <<<<<<<<<<<<<<
- *                     name = str(args[3])
- *             if len(args) == 5:
+      __pyx_t_4 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 6, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_4 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_4 = __Pyx_PyBool_FromLong((!(!__pyx_t_1))); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 57; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_v_doipol = __pyx_t_4;
+      __pyx_t_4 = 0;
+
+      /* "professor2/core.pyx":58
+ *                 histname = str(args[5])
+ *                 doipol = bool(args[6])
+ *                 order = int(args[7])             # <<<<<<<<<<<<<<
+ *                 fitparams = list(args[8])
+ *                 config = str(args[9])
  */
-        /*except:*/ {
-          __Pyx_AddTraceback("professor2.core.Ipol.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-          if (__Pyx_GetException(&__pyx_t_4, &__pyx_t_8, &__pyx_t_13) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
-          __Pyx_GOTREF(__pyx_t_4);
-          __Pyx_GOTREF(__pyx_t_8);
-          __Pyx_GOTREF(__pyx_t_13);
-
-          /* "professor2/core.pyx":59
- *                     threshold = float(args[3])
- *                 except:
- *                     name = str(args[3])             # <<<<<<<<<<<<<<
- *             if len(args) == 5:
- *                     name = str(args[3])
+      __pyx_t_4 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 7, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_4 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_8 = PyNumber_Int(__pyx_t_4); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF_SET(__pyx_v_order, __pyx_t_8);
+      __pyx_t_8 = 0;
+
+      /* "professor2/core.pyx":59
+ *                 doipol = bool(args[6])
+ *                 order = int(args[7])
+ *                 fitparams = list(args[8])             # <<<<<<<<<<<<<<
+ *                 config = str(args[9])
+ *                 self._ptr = new c.Ipol(deref(pp._ptr), vals, errs, bin_num, histname, doipol, order, fitparams, config)
  */
-          __pyx_t_14 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_14 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 59; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;};
-          __Pyx_GOTREF(__pyx_t_14);
-          __pyx_t_15 = PyTuple_New(1); if (unlikely(!__pyx_t_15)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 59; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
-          __Pyx_GOTREF(__pyx_t_15);
-          __Pyx_GIVEREF(__pyx_t_14);
-          PyTuple_SET_ITEM(__pyx_t_15, 0, __pyx_t_14);
-          __pyx_t_14 = 0;
-          __pyx_t_14 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_15, NULL); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 59; __pyx_clineno = __LINE__; goto __pyx_L9_except_error;}
-          __Pyx_GOTREF(__pyx_t_14);
-          __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
-          __Pyx_DECREF_SET(__pyx_v_name, __pyx_t_14);
-          __pyx_t_14 = 0;
-          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-          __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-          goto __pyx_L8_exception_handled;
-        }
-        __pyx_L9_except_error:;
+      __pyx_t_8 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 8, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_8 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 59; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+      __Pyx_GOTREF(__pyx_t_8);
+      __pyx_t_4 = PySequence_List(__pyx_t_8); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 59; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __pyx_v_fitparams = ((PyObject*)__pyx_t_4);
+      __pyx_t_4 = 0;
 
-        /* "professor2/core.pyx":56
- *             threshold = 1e-40 #< ???
- *             if len(args) == 4:
- *                 try:             # <<<<<<<<<<<<<<
- *                     threshold = float(args[3])
- *                 except:
- */
-        __Pyx_XGIVEREF(__pyx_t_9);
-        __Pyx_XGIVEREF(__pyx_t_10);
-        __Pyx_XGIVEREF(__pyx_t_11);
-        __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
-        goto __pyx_L1_error;
-        __pyx_L8_exception_handled:;
-        __Pyx_XGIVEREF(__pyx_t_9);
-        __Pyx_XGIVEREF(__pyx_t_10);
-        __Pyx_XGIVEREF(__pyx_t_11);
-        __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
-        __pyx_L14_try_end:;
+      /* "professor2/core.pyx":60
+ *                 order = int(args[7])
+ *                 fitparams = list(args[8])
+ *                 config = str(args[9])             # <<<<<<<<<<<<<<
+ *                 self._ptr = new c.Ipol(deref(pp._ptr), vals, errs, bin_num, histname, doipol, order, fitparams, config)
+ *             else:
+ */
+      __pyx_t_4 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 9, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_4 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_GIVEREF(__pyx_t_4);
+      PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_8, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __pyx_v_config = __pyx_t_4;
+      __pyx_t_4 = 0;
+
+      /* "professor2/core.pyx":61
+ *                 fitparams = list(args[8])
+ *                 config = str(args[9])
+ *                 self._ptr = new c.Ipol(deref(pp._ptr), vals, errs, bin_num, histname, doipol, order, fitparams, config)             # <<<<<<<<<<<<<<
+ *             else:
+ *                 name = ""
+ */
+      __pyx_t_9 = __pyx_convert_vector_from_py_double(__pyx_v_vals); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_10 = __pyx_convert_vector_from_py_double(__pyx_v_errs); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_11 = __Pyx_PyInt_As_int(__pyx_v_bin_num); if (unlikely((__pyx_t_11 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_6 = __pyx_convert_string_from_py_std__in_string(__pyx_v_histname); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_12 = __Pyx_PyObject_IsTrue(__pyx_v_doipol); if (unlikely((__pyx_t_12 == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_13 = __Pyx_PyInt_As_int(__pyx_v_order); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_14 = __pyx_convert_vector_from_py_double(__pyx_v_fitparams); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_15 = __pyx_convert_string_from_py_std__in_string(__pyx_v_config); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      try {
+        __pyx_t_7 = new Professor::Ipol((*__pyx_v_pp->_ptr), __pyx_t_9, __pyx_t_10, __pyx_t_11, __pyx_t_6, __pyx_t_12, __pyx_t_13, __pyx_t_14, __pyx_t_15);
+      } catch(...) {
+        __Pyx_CppExn2PyErr();
+        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       }
+      __pyx_v_self->_ptr = __pyx_t_7;
 
-      /* "professor2/core.pyx":55
- *             name = ""
- *             threshold = 1e-40 #< ???
- *             if len(args) == 4:             # <<<<<<<<<<<<<<
- *                 try:
- *                     threshold = float(args[3])
+      /* "professor2/core.pyx":53
+ *             vals = list(args[1])
+ *             order = int(args[2])
+ *             if order < 0:             # <<<<<<<<<<<<<<
+ *                 errs = list(args[3])
+ *                 bin_num = int(args[4])
  */
+      goto __pyx_L6;
     }
 
-    /* "professor2/core.pyx":60
- *                 except:
- *                     name = str(args[3])
- *             if len(args) == 5:             # <<<<<<<<<<<<<<
+    /* "professor2/core.pyx":63
+ *                 self._ptr = new c.Ipol(deref(pp._ptr), vals, errs, bin_num, histname, doipol, order, fitparams, config)
+ *             else:
+ *                 name = ""             # <<<<<<<<<<<<<<
+ *                 threshold = 1e-40 #< ???
+ *                 if len(args) == 4:
+ */
+    /*else*/ {
+      __Pyx_INCREF(__pyx_kp_s__3);
+      __pyx_v_name = __pyx_kp_s__3;
+
+      /* "professor2/core.pyx":64
+ *             else:
+ *                 name = ""
+ *                 threshold = 1e-40 #< ???             # <<<<<<<<<<<<<<
+ *                 if len(args) == 4:
+ *                     try:
+ */
+      __pyx_v_threshold = 1e-40;
+
+      /* "professor2/core.pyx":65
+ *                 name = ""
+ *                 threshold = 1e-40 #< ???
+ *                 if len(args) == 4:             # <<<<<<<<<<<<<<
+ *                     try:
+ *                         threshold = float(args[3])
+ */
+      __pyx_t_2 = PyTuple_GET_SIZE(__pyx_v_args); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 65; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_1 = ((__pyx_t_2 == 4) != 0);
+      if (__pyx_t_1) {
+
+        /* "professor2/core.pyx":66
+ *                 threshold = 1e-40 #< ???
+ *                 if len(args) == 4:
+ *                     try:             # <<<<<<<<<<<<<<
+ *                         threshold = float(args[3])
+ *                     except:
+ */
+        {
+          __Pyx_ExceptionSave(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18);
+          __Pyx_XGOTREF(__pyx_t_16);
+          __Pyx_XGOTREF(__pyx_t_17);
+          __Pyx_XGOTREF(__pyx_t_18);
+          /*try:*/ {
+
+            /* "professor2/core.pyx":67
+ *                 if len(args) == 4:
+ *                     try:
+ *                         threshold = float(args[3])             # <<<<<<<<<<<<<<
+ *                     except:
+ *                         name = str(args[3])
+ */
+            __pyx_t_4 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_4 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 67; __pyx_clineno = __LINE__; goto __pyx_L8_error;};
+            __Pyx_GOTREF(__pyx_t_4);
+            __pyx_t_19 = __Pyx_PyObject_AsDouble(__pyx_t_4); if (unlikely(__pyx_t_19 == ((double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 67; __pyx_clineno = __LINE__; goto __pyx_L8_error;}
+            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+            __pyx_v_threshold = __pyx_t_19;
+
+            /* "professor2/core.pyx":66
+ *                 threshold = 1e-40 #< ???
+ *                 if len(args) == 4:
+ *                     try:             # <<<<<<<<<<<<<<
+ *                         threshold = float(args[3])
+ *                     except:
+ */
+          }
+          __Pyx_XDECREF(__pyx_t_16); __pyx_t_16 = 0;
+          __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
+          __Pyx_XDECREF(__pyx_t_18); __pyx_t_18 = 0;
+          goto __pyx_L15_try_end;
+          __pyx_L8_error:;
+          __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+          /* "professor2/core.pyx":68
+ *                     try:
+ *                         threshold = float(args[3])
+ *                     except:             # <<<<<<<<<<<<<<
+ *                         name = str(args[3])
+ *                 if len(args) == 5:
+ */
+          /*except:*/ {
+            __Pyx_AddTraceback("professor2.core.Ipol.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+            if (__Pyx_GetException(&__pyx_t_4, &__pyx_t_8, &__pyx_t_20) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L10_except_error;}
+            __Pyx_GOTREF(__pyx_t_4);
+            __Pyx_GOTREF(__pyx_t_8);
+            __Pyx_GOTREF(__pyx_t_20);
+
+            /* "professor2/core.pyx":69
+ *                         threshold = float(args[3])
+ *                     except:
+ *                         name = str(args[3])             # <<<<<<<<<<<<<<
+ *                 if len(args) == 5:
  *                     name = str(args[3])
- *                     threshold = float(args[4])
  */
-    __pyx_t_2 = PyTuple_GET_SIZE(__pyx_v_args); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_1 = ((__pyx_t_2 == 5) != 0);
-    if (__pyx_t_1) {
+            __pyx_t_21 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_21 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L10_except_error;};
+            __Pyx_GOTREF(__pyx_t_21);
+            __pyx_t_22 = PyTuple_New(1); if (unlikely(!__pyx_t_22)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L10_except_error;}
+            __Pyx_GOTREF(__pyx_t_22);
+            __Pyx_GIVEREF(__pyx_t_21);
+            PyTuple_SET_ITEM(__pyx_t_22, 0, __pyx_t_21);
+            __pyx_t_21 = 0;
+            __pyx_t_21 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_22, NULL); if (unlikely(!__pyx_t_21)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L10_except_error;}
+            __Pyx_GOTREF(__pyx_t_21);
+            __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
+            __Pyx_DECREF_SET(__pyx_v_name, __pyx_t_21);
+            __pyx_t_21 = 0;
+            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+            __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+            __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
+            goto __pyx_L9_exception_handled;
+          }
+          __pyx_L10_except_error:;
+
+          /* "professor2/core.pyx":66
+ *                 threshold = 1e-40 #< ???
+ *                 if len(args) == 4:
+ *                     try:             # <<<<<<<<<<<<<<
+ *                         threshold = float(args[3])
+ *                     except:
+ */
+          __Pyx_XGIVEREF(__pyx_t_16);
+          __Pyx_XGIVEREF(__pyx_t_17);
+          __Pyx_XGIVEREF(__pyx_t_18);
+          __Pyx_ExceptionReset(__pyx_t_16, __pyx_t_17, __pyx_t_18);
+          goto __pyx_L1_error;
+          __pyx_L9_exception_handled:;
+          __Pyx_XGIVEREF(__pyx_t_16);
+          __Pyx_XGIVEREF(__pyx_t_17);
+          __Pyx_XGIVEREF(__pyx_t_18);
+          __Pyx_ExceptionReset(__pyx_t_16, __pyx_t_17, __pyx_t_18);
+          __pyx_L15_try_end:;
+        }
 
-      /* "professor2/core.pyx":61
+        /* "professor2/core.pyx":65
+ *                 name = ""
+ *                 threshold = 1e-40 #< ???
+ *                 if len(args) == 4:             # <<<<<<<<<<<<<<
+ *                     try:
+ *                         threshold = float(args[3])
+ */
+      }
+
+      /* "professor2/core.pyx":70
+ *                     except:
+ *                         name = str(args[3])
+ *                 if len(args) == 5:             # <<<<<<<<<<<<<<
  *                     name = str(args[3])
- *             if len(args) == 5:
+ *                     threshold = float(args[4])
+ */
+      __pyx_t_2 = PyTuple_GET_SIZE(__pyx_v_args); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_1 = ((__pyx_t_2 == 5) != 0);
+      if (__pyx_t_1) {
+
+        /* "professor2/core.pyx":71
+ *                         name = str(args[3])
+ *                 if len(args) == 5:
  *                     name = str(args[3])             # <<<<<<<<<<<<<<
  *                     threshold = float(args[4])
- *             self._ptr = new c.Ipol(deref(pp._ptr), vals, order, name, threshold, True)
+ *                 self._ptr = new c.Ipol(deref(pp._ptr), vals, order, name, threshold, True)
  */
-      __pyx_t_13 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_13 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-      __Pyx_GOTREF(__pyx_t_13);
-      __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_8);
-      __Pyx_GIVEREF(__pyx_t_13);
-      PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_13);
-      __pyx_t_13 = 0;
-      __pyx_t_13 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_8, NULL); if (unlikely(!__pyx_t_13)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 61; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_GOTREF(__pyx_t_13);
-      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __Pyx_DECREF_SET(__pyx_v_name, __pyx_t_13);
-      __pyx_t_13 = 0;
+        __pyx_t_20 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 3, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_20 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 71; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+        __Pyx_GOTREF(__pyx_t_20);
+        __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 71; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_8);
+        __Pyx_GIVEREF(__pyx_t_20);
+        PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_20);
+        __pyx_t_20 = 0;
+        __pyx_t_20 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_8, NULL); if (unlikely(!__pyx_t_20)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 71; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_20);
+        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __Pyx_DECREF_SET(__pyx_v_name, __pyx_t_20);
+        __pyx_t_20 = 0;
 
-      /* "professor2/core.pyx":62
- *             if len(args) == 5:
+        /* "professor2/core.pyx":72
+ *                 if len(args) == 5:
  *                     name = str(args[3])
  *                     threshold = float(args[4])             # <<<<<<<<<<<<<<
- *             self._ptr = new c.Ipol(deref(pp._ptr), vals, order, name, threshold, True)
+ *                 self._ptr = new c.Ipol(deref(pp._ptr), vals, order, name, threshold, True)
  * 
  */
-      __pyx_t_13 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 4, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_13 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
-      __Pyx_GOTREF(__pyx_t_13);
-      __pyx_t_12 = __Pyx_PyObject_AsDouble(__pyx_t_13); if (unlikely(__pyx_t_12 == ((double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 62; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
-      __pyx_v_threshold = __pyx_t_12;
-
-      /* "professor2/core.pyx":60
- *                 except:
- *                     name = str(args[3])
- *             if len(args) == 5:             # <<<<<<<<<<<<<<
+        __pyx_t_20 = __Pyx_GetItemInt_Tuple(__pyx_v_args, 4, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_20 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+        __Pyx_GOTREF(__pyx_t_20);
+        __pyx_t_19 = __Pyx_PyObject_AsDouble(__pyx_t_20); if (unlikely(__pyx_t_19 == ((double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_20); __pyx_t_20 = 0;
+        __pyx_v_threshold = __pyx_t_19;
+
+        /* "professor2/core.pyx":70
+ *                     except:
+ *                         name = str(args[3])
+ *                 if len(args) == 5:             # <<<<<<<<<<<<<<
  *                     name = str(args[3])
  *                     threshold = float(args[4])
  */
-    }
+      }
 
-    /* "professor2/core.pyx":63
+      /* "professor2/core.pyx":73
  *                     name = str(args[3])
  *                     threshold = float(args[4])
- *             self._ptr = new c.Ipol(deref(pp._ptr), vals, order, name, threshold, True)             # <<<<<<<<<<<<<<
+ *                 self._ptr = new c.Ipol(deref(pp._ptr), vals, order, name, threshold, True)             # <<<<<<<<<<<<<<
  * 
  *     def __del__(self):
  */
-    __pyx_t_16 = __pyx_convert_vector_from_py_double(__pyx_v_vals); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 63; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_17 = __Pyx_PyInt_As_int(__pyx_v_order); if (unlikely((__pyx_t_17 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 63; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_6 = __pyx_convert_string_from_py_std__in_string(__pyx_v_name); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 63; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    try {
-      __pyx_t_7 = new Professor::Ipol((*__pyx_v_pp->_ptr), __pyx_t_16, __pyx_t_17, __pyx_t_6, __pyx_v_threshold, 1);
-    } catch(...) {
-      __Pyx_CppExn2PyErr();
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 63; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_14 = __pyx_convert_vector_from_py_double(__pyx_v_vals); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 73; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_13 = __Pyx_PyInt_As_int(__pyx_v_order); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 73; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_15 = __pyx_convert_string_from_py_std__in_string(__pyx_v_name); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 73; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      try {
+        __pyx_t_7 = new Professor::Ipol((*__pyx_v_pp->_ptr), __pyx_t_14, __pyx_t_13, __pyx_t_15, __pyx_v_threshold, 1);
+      } catch(...) {
+        __Pyx_CppExn2PyErr();
+        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 73; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      }
+      __pyx_v_self->_ptr = __pyx_t_7;
     }
-    __pyx_v_self->_ptr = __pyx_t_7;
+    __pyx_L6:;
   }
   __pyx_L3:;
 
@@ -1722,22 +1898,28 @@
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_8);
-  __Pyx_XDECREF(__pyx_t_13);
-  __Pyx_XDECREF(__pyx_t_14);
-  __Pyx_XDECREF(__pyx_t_15);
+  __Pyx_XDECREF(__pyx_t_20);
+  __Pyx_XDECREF(__pyx_t_21);
+  __Pyx_XDECREF(__pyx_t_22);
   __Pyx_AddTraceback("professor2.core.Ipol.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_XDECREF((PyObject *)__pyx_v_pp);
   __Pyx_XDECREF(__pyx_v_vals);
   __Pyx_XDECREF(__pyx_v_order);
+  __Pyx_XDECREF(__pyx_v_errs);
+  __Pyx_XDECREF(__pyx_v_bin_num);
+  __Pyx_XDECREF(__pyx_v_histname);
+  __Pyx_XDECREF(__pyx_v_doipol);
+  __Pyx_XDECREF(__pyx_v_fitparams);
+  __Pyx_XDECREF(__pyx_v_config);
   __Pyx_XDECREF(__pyx_v_name);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":65
- *             self._ptr = new c.Ipol(deref(pp._ptr), vals, order, name, threshold, True)
+/* "professor2/core.pyx":75
+ *                 self._ptr = new c.Ipol(deref(pp._ptr), vals, order, name, threshold, True)
  * 
  *     def __del__(self):             # <<<<<<<<<<<<<<
  *         del self._ptr
@@ -1763,7 +1945,7 @@
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__del__", 0);
 
-  /* "professor2/core.pyx":66
+  /* "professor2/core.pyx":76
  * 
  *     def __del__(self):
  *         del self._ptr             # <<<<<<<<<<<<<<
@@ -1772,8 +1954,8 @@
  */
   delete __pyx_v_self->_ptr;
 
-  /* "professor2/core.pyx":65
- *             self._ptr = new c.Ipol(deref(pp._ptr), vals, order, name, threshold, True)
+  /* "professor2/core.pyx":75
+ *                 self._ptr = new c.Ipol(deref(pp._ptr), vals, order, name, threshold, True)
  * 
  *     def __del__(self):             # <<<<<<<<<<<<<<
  *         del self._ptr
@@ -1787,7 +1969,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":68
+/* "professor2/core.pyx":78
  *         del self._ptr
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
@@ -1810,7 +1992,7 @@
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__dealloc__", 0);
 
-  /* "professor2/core.pyx":69
+  /* "professor2/core.pyx":79
  * 
  *     def __dealloc__(self):
  *         del self._ptr             # <<<<<<<<<<<<<<
@@ -1819,7 +2001,7 @@
  */
   delete __pyx_v_self->_ptr;
 
-  /* "professor2/core.pyx":68
+  /* "professor2/core.pyx":78
  *         del self._ptr
  * 
  *     def __dealloc__(self):             # <<<<<<<<<<<<<<
@@ -1831,7 +2013,7 @@
   __Pyx_RefNannyFinishContext();
 }
 
-/* "professor2/core.pyx":73
+/* "professor2/core.pyx":83
  * 
  *     @property
  *     def coeffs(self):             # <<<<<<<<<<<<<<
@@ -1863,7 +2045,7 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("coeffs", 0);
 
-  /* "professor2/core.pyx":74
+  /* "professor2/core.pyx":84
  *     @property
  *     def coeffs(self):
  *         return self._ptr.coeffs()             # <<<<<<<<<<<<<<
@@ -1875,15 +2057,15 @@
     __pyx_t_1 = __pyx_v_self->_ptr->coeffs();
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 84; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_t_2 = __pyx_convert_vector_to_py_double(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 74; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __pyx_convert_vector_to_py_double(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 84; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":73
+  /* "professor2/core.pyx":83
  * 
  *     @property
  *     def coeffs(self):             # <<<<<<<<<<<<<<
@@ -1902,7 +2084,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":77
+/* "professor2/core.pyx":87
  * 
  *     @property
  *     def structure(self):             # <<<<<<<<<<<<<<
@@ -1934,7 +2116,7 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("structure", 0);
 
-  /* "professor2/core.pyx":79
+  /* "professor2/core.pyx":89
  *     def structure(self):
  *         #rtn = []
  *         return self._ptr.structure()             # <<<<<<<<<<<<<<
@@ -1946,15 +2128,15 @@
     __pyx_t_1 = __pyx_v_self->_ptr->structure();
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 89; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_t_2 = __pyx_convert_vector_to_py_std_3a__3a_vector_3c_int_3e___(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __pyx_convert_vector_to_py_std_3a__3a_vector_3c_int_3e___(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 89; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":77
+  /* "professor2/core.pyx":87
  * 
  *     @property
  *     def structure(self):             # <<<<<<<<<<<<<<
@@ -1973,7 +2155,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":81
+/* "professor2/core.pyx":91
  *         return self._ptr.structure()
  * 
  *     def longvector(self, params):             # <<<<<<<<<<<<<<
@@ -2006,7 +2188,7 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("longvector", 0);
 
-  /* "professor2/core.pyx":82
+  /* "professor2/core.pyx":92
  * 
  *     def longvector(self, params):
  *         return self._ptr.longVector(params)             # <<<<<<<<<<<<<<
@@ -2014,20 +2196,20 @@
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_convert_vector_from_py_double(__pyx_v_params); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __pyx_convert_vector_from_py_double(__pyx_v_params); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 92; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   try {
     __pyx_t_2 = __pyx_v_self->_ptr->longVector(__pyx_t_1);
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 92; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_t_3 = __pyx_convert_vector_to_py_double(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = __pyx_convert_vector_to_py_double(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 92; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":81
+  /* "professor2/core.pyx":91
  *         return self._ptr.structure()
  * 
  *     def longvector(self, params):             # <<<<<<<<<<<<<<
@@ -2046,7 +2228,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":85
+/* "professor2/core.pyx":95
  * 
  *     @property
  *     def dim(self):             # <<<<<<<<<<<<<<
@@ -2078,7 +2260,7 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("dim", 0);
 
-  /* "professor2/core.pyx":86
+  /* "professor2/core.pyx":96
  *     @property
  *     def dim(self):
  *         return self._ptr.dim()             # <<<<<<<<<<<<<<
@@ -2090,15 +2272,15 @@
     __pyx_t_1 = __pyx_v_self->_ptr->dim();
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":85
+  /* "professor2/core.pyx":95
  * 
  *     @property
  *     def dim(self):             # <<<<<<<<<<<<<<
@@ -2117,7 +2299,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":89
+/* "professor2/core.pyx":99
  * 
  *     @property
  *     def order(self):             # <<<<<<<<<<<<<<
@@ -2149,7 +2331,7 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("order", 0);
 
-  /* "professor2/core.pyx":90
+  /* "professor2/core.pyx":100
  *     @property
  *     def order(self):
  *         return self._ptr.order()             # <<<<<<<<<<<<<<
@@ -2161,15 +2343,15 @@
     __pyx_t_1 = __pyx_v_self->_ptr->order();
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":89
+  /* "professor2/core.pyx":99
  * 
  *     @property
  *     def order(self):             # <<<<<<<<<<<<<<
@@ -2188,7 +2370,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":93
+/* "professor2/core.pyx":103
  * 
  *     @property
  *     def name(self):             # <<<<<<<<<<<<<<
@@ -2220,7 +2402,7 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("name", 0);
 
-  /* "professor2/core.pyx":94
+  /* "professor2/core.pyx":104
  *     @property
  *     def name(self):
  *         return self._ptr.name()             # <<<<<<<<<<<<<<
@@ -2232,15 +2414,15 @@
     __pyx_t_1 = __pyx_v_self->_ptr->name();
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_t_2 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":93
+  /* "professor2/core.pyx":103
  * 
  *     @property
  *     def name(self):             # <<<<<<<<<<<<<<
@@ -2259,7 +2441,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":96
+/* "professor2/core.pyx":106
  *         return self._ptr.name()
  * 
  *     def value(self, *params, vmin=None, vmax=None):             # <<<<<<<<<<<<<<
@@ -2311,7 +2493,7 @@
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, 0, "value") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, 0, "value") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) < 0) {
       goto __pyx_L5_argtuple_error;
@@ -2322,7 +2504,7 @@
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("value", 0, 0, 0, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __Pyx_RaiseArgtupleInvalid("value", 0, 0, 0, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
   __pyx_L3_error:;
   __Pyx_DECREF(__pyx_v_params); __pyx_v_params = 0;
   __Pyx_AddTraceback("professor2.core.Ipol.value", __pyx_clineno, __pyx_lineno, __pyx_filename);
@@ -2359,37 +2541,37 @@
   __Pyx_RefNannySetupContext("value", 0);
   __Pyx_INCREF(__pyx_v_params);
 
-  /* "professor2/core.pyx":104
+  /* "professor2/core.pyx":114
  *         """
  * 
  *         import collections             # <<<<<<<<<<<<<<
  * 
  *         ## Detect if the params have been passed as a single iterable and convert
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_collections, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 104; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_collections, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_collections = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "professor2/core.pyx":107
+  /* "professor2/core.pyx":117
  * 
  *         ## Detect if the params have been passed as a single iterable and convert
  *         if len(params) == 1 and isinstance(params[0], collections.Iterable):             # <<<<<<<<<<<<<<
  *             params = params[0]
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  */
-  __pyx_t_3 = PyObject_Length(__pyx_v_params); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = PyObject_Length(__pyx_v_params); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_t_4 = ((__pyx_t_3 == 1) != 0);
   if (__pyx_t_4) {
   } else {
     __pyx_t_2 = __pyx_t_4;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_params, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 107; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_params, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_collections, __pyx_n_s_Iterable); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_collections, __pyx_n_s_Iterable); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_4 = PyObject_IsInstance(__pyx_t_1, __pyx_t_5); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = PyObject_IsInstance(__pyx_t_1, __pyx_t_5); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_t_6 = (__pyx_t_4 != 0);
@@ -2397,40 +2579,40 @@
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_2) {
 
-    /* "professor2/core.pyx":108
+    /* "professor2/core.pyx":118
  *         ## Detect if the params have been passed as a single iterable and convert
  *         if len(params) == 1 and isinstance(params[0], collections.Iterable):
  *             params = params[0]             # <<<<<<<<<<<<<<
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  *             if isinstance(params, collections.Mapping):
  */
-    __pyx_t_5 = __Pyx_GetItemInt_Tuple(__pyx_v_params, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_5 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 108; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+    __pyx_t_5 = __Pyx_GetItemInt_Tuple(__pyx_v_params, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_5 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF_SET(__pyx_v_params, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "professor2/core.pyx":110
+    /* "professor2/core.pyx":120
  *             params = params[0]
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  *             if isinstance(params, collections.Mapping):             # <<<<<<<<<<<<<<
  *                 params = params.values()
  * 
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_collections, __pyx_n_s_Mapping); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_collections, __pyx_n_s_Mapping); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_2 = PyObject_IsInstance(__pyx_v_params, __pyx_t_5); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 110; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_2 = PyObject_IsInstance(__pyx_v_params, __pyx_t_5); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_t_6 = (__pyx_t_2 != 0);
     if (__pyx_t_6) {
 
-      /* "professor2/core.pyx":111
+      /* "professor2/core.pyx":121
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  *             if isinstance(params, collections.Mapping):
  *                 params = params.values()             # <<<<<<<<<<<<<<
  * 
  *         ## Ensure that the param values are floats
  */
-      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_params, __pyx_n_s_values); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 111; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_params, __pyx_n_s_values); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_1);
       __pyx_t_7 = NULL;
       if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_1))) {
@@ -2443,17 +2625,17 @@
         }
       }
       if (__pyx_t_7) {
-        __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_7); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 111; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_7); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
       } else {
-        __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 111; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       }
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __Pyx_DECREF_SET(__pyx_v_params, __pyx_t_5);
       __pyx_t_5 = 0;
 
-      /* "professor2/core.pyx":110
+      /* "professor2/core.pyx":120
  *             params = params[0]
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  *             if isinstance(params, collections.Mapping):             # <<<<<<<<<<<<<<
@@ -2462,7 +2644,7 @@
  */
     }
 
-    /* "professor2/core.pyx":107
+    /* "professor2/core.pyx":117
  * 
  *         ## Detect if the params have been passed as a single iterable and convert
  *         if len(params) == 1 and isinstance(params[0], collections.Iterable):             # <<<<<<<<<<<<<<
@@ -2471,39 +2653,39 @@
  */
   }
 
-  /* "professor2/core.pyx":114
+  /* "professor2/core.pyx":124
  * 
  *         ## Ensure that the param values are floats
  *         params = [float(p) for p in params]             # <<<<<<<<<<<<<<
  * 
  *         ## Compute the interpolated value at 'params' and impose optional range limits
  */
-  __pyx_t_5 = PyList_New(0); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = PyList_New(0); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_5);
   if (likely(PyList_CheckExact(__pyx_v_params)) || PyTuple_CheckExact(__pyx_v_params)) {
     __pyx_t_1 = __pyx_v_params; __Pyx_INCREF(__pyx_t_1); __pyx_t_3 = 0;
     __pyx_t_8 = NULL;
   } else {
-    __pyx_t_3 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_params); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_params); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_8 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_8 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
   for (;;) {
     if (likely(!__pyx_t_8)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_COMPILING_IN_CPYTHON
-        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       } else {
         if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_COMPILING_IN_CPYTHON
-        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       }
@@ -2513,7 +2695,7 @@
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         }
         break;
       }
@@ -2521,33 +2703,33 @@
     }
     __Pyx_XDECREF_SET(__pyx_v_p, __pyx_t_7);
     __pyx_t_7 = 0;
-    __pyx_t_9 = __Pyx_PyObject_AsDouble(__pyx_v_p); if (unlikely(__pyx_t_9 == ((double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_7 = PyFloat_FromDouble(__pyx_t_9); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_9 = __Pyx_PyObject_AsDouble(__pyx_v_p); if (unlikely(__pyx_t_9 == ((double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_7 = PyFloat_FromDouble(__pyx_t_9); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_7);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_5, (PyObject*)__pyx_t_7))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_5, (PyObject*)__pyx_t_7))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF_SET(__pyx_v_params, __pyx_t_5);
   __pyx_t_5 = 0;
 
-  /* "professor2/core.pyx":117
+  /* "professor2/core.pyx":127
  * 
  *         ## Compute the interpolated value at 'params' and impose optional range limits
  *         v = self._ptr.value(params)             # <<<<<<<<<<<<<<
  *         if vmin is not None and v < vmin:
  *             return vmin
  */
-  __pyx_t_10 = __pyx_convert_vector_from_py_double(__pyx_v_params); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_10 = __pyx_convert_vector_from_py_double(__pyx_v_params); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   try {
     __pyx_t_9 = __pyx_v_self->_ptr->value(__pyx_t_10);
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 117; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
   __pyx_v_v = __pyx_t_9;
 
-  /* "professor2/core.pyx":118
+  /* "professor2/core.pyx":128
  *         ## Compute the interpolated value at 'params' and impose optional range limits
  *         v = self._ptr.value(params)
  *         if vmin is not None and v < vmin:             # <<<<<<<<<<<<<<
@@ -2561,17 +2743,17 @@
     __pyx_t_6 = __pyx_t_4;
     goto __pyx_L10_bool_binop_done;
   }
-  __pyx_t_5 = PyFloat_FromDouble(__pyx_v_v); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = PyFloat_FromDouble(__pyx_v_v); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_1 = PyObject_RichCompare(__pyx_t_5, __pyx_v_vmin, Py_LT); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyObject_RichCompare(__pyx_t_5, __pyx_v_vmin, Py_LT); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 118; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 128; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_6 = __pyx_t_4;
   __pyx_L10_bool_binop_done:;
   if (__pyx_t_6) {
 
-    /* "professor2/core.pyx":119
+    /* "professor2/core.pyx":129
  *         v = self._ptr.value(params)
  *         if vmin is not None and v < vmin:
  *             return vmin             # <<<<<<<<<<<<<<
@@ -2583,7 +2765,7 @@
     __pyx_r = __pyx_v_vmin;
     goto __pyx_L0;
 
-    /* "professor2/core.pyx":118
+    /* "professor2/core.pyx":128
  *         ## Compute the interpolated value at 'params' and impose optional range limits
  *         v = self._ptr.value(params)
  *         if vmin is not None and v < vmin:             # <<<<<<<<<<<<<<
@@ -2592,7 +2774,7 @@
  */
   }
 
-  /* "professor2/core.pyx":120
+  /* "professor2/core.pyx":130
  *         if vmin is not None and v < vmin:
  *             return vmin
  *         if vmax is not None and v > vmax:             # <<<<<<<<<<<<<<
@@ -2606,17 +2788,17 @@
     __pyx_t_6 = __pyx_t_2;
     goto __pyx_L13_bool_binop_done;
   }
-  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_v); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_v); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = PyObject_RichCompare(__pyx_t_1, __pyx_v_vmax, Py_GT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = PyObject_RichCompare(__pyx_t_1, __pyx_v_vmax, Py_GT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_t_6 = __pyx_t_2;
   __pyx_L13_bool_binop_done:;
   if (__pyx_t_6) {
 
-    /* "professor2/core.pyx":121
+    /* "professor2/core.pyx":131
  *             return vmin
  *         if vmax is not None and v > vmax:
  *             return vmax             # <<<<<<<<<<<<<<
@@ -2628,7 +2810,7 @@
     __pyx_r = __pyx_v_vmax;
     goto __pyx_L0;
 
-    /* "professor2/core.pyx":120
+    /* "professor2/core.pyx":130
  *         if vmin is not None and v < vmin:
  *             return vmin
  *         if vmax is not None and v > vmax:             # <<<<<<<<<<<<<<
@@ -2637,7 +2819,7 @@
  */
   }
 
-  /* "professor2/core.pyx":123
+  /* "professor2/core.pyx":133
  *             return vmax
  * 
  *         return v             # <<<<<<<<<<<<<<
@@ -2645,13 +2827,13 @@
  *     ## Alias
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_5 = PyFloat_FromDouble(__pyx_v_v); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 123; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = PyFloat_FromDouble(__pyx_v_v); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":96
+  /* "professor2/core.pyx":106
  *         return self._ptr.name()
  * 
  *     def value(self, *params, vmin=None, vmax=None):             # <<<<<<<<<<<<<<
@@ -2675,7 +2857,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":129
+/* "professor2/core.pyx":139
  * 
  * 
  *     def derivative(self, *params):             # <<<<<<<<<<<<<<
@@ -2723,37 +2905,37 @@
   __Pyx_RefNannySetupContext("derivative", 0);
   __Pyx_INCREF(__pyx_v_params);
 
-  /* "professor2/core.pyx":130
+  /* "professor2/core.pyx":140
  * 
  *     def derivative(self, *params):
  *         import collections             # <<<<<<<<<<<<<<
  * 
  *         ## Detect if the params have been passed as a single iterable and convert
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_collections, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_collections, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_collections = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "professor2/core.pyx":133
+  /* "professor2/core.pyx":143
  * 
  *         ## Detect if the params have been passed as a single iterable and convert
  *         if len(params) == 1 and isinstance(params[0], collections.Iterable):             # <<<<<<<<<<<<<<
  *             params = params[0]
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  */
-  __pyx_t_3 = PyObject_Length(__pyx_v_params); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = PyObject_Length(__pyx_v_params); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_t_4 = ((__pyx_t_3 == 1) != 0);
   if (__pyx_t_4) {
   } else {
     __pyx_t_2 = __pyx_t_4;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_params, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_params, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_collections, __pyx_n_s_Iterable); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_collections, __pyx_n_s_Iterable); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_4 = PyObject_IsInstance(__pyx_t_1, __pyx_t_5); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 133; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = PyObject_IsInstance(__pyx_t_1, __pyx_t_5); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_t_6 = (__pyx_t_4 != 0);
@@ -2761,40 +2943,40 @@
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_2) {
 
-    /* "professor2/core.pyx":134
+    /* "professor2/core.pyx":144
  *         ## Detect if the params have been passed as a single iterable and convert
  *         if len(params) == 1 and isinstance(params[0], collections.Iterable):
  *             params = params[0]             # <<<<<<<<<<<<<<
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  *             if isinstance(params, collections.Mapping):
  */
-    __pyx_t_5 = __Pyx_GetItemInt_Tuple(__pyx_v_params, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_5 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 134; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+    __pyx_t_5 = __Pyx_GetItemInt_Tuple(__pyx_v_params, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_5 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF_SET(__pyx_v_params, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "professor2/core.pyx":136
+    /* "professor2/core.pyx":146
  *             params = params[0]
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  *             if isinstance(params, collections.Mapping):             # <<<<<<<<<<<<<<
  *                 params = params.values()
  * 
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_collections, __pyx_n_s_Mapping); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_collections, __pyx_n_s_Mapping); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_2 = PyObject_IsInstance(__pyx_v_params, __pyx_t_5); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_2 = PyObject_IsInstance(__pyx_v_params, __pyx_t_5); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_t_6 = (__pyx_t_2 != 0);
     if (__pyx_t_6) {
 
-      /* "professor2/core.pyx":137
+      /* "professor2/core.pyx":147
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  *             if isinstance(params, collections.Mapping):
  *                 params = params.values()             # <<<<<<<<<<<<<<
  * 
  *         ## Ensure that the param values are floats
  */
-      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_params, __pyx_n_s_values); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_params, __pyx_n_s_values); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_1);
       __pyx_t_7 = NULL;
       if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_1))) {
@@ -2807,17 +2989,17 @@
         }
       }
       if (__pyx_t_7) {
-        __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_7); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_7); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
       } else {
-        __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       }
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __Pyx_DECREF_SET(__pyx_v_params, __pyx_t_5);
       __pyx_t_5 = 0;
 
-      /* "professor2/core.pyx":136
+      /* "professor2/core.pyx":146
  *             params = params[0]
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  *             if isinstance(params, collections.Mapping):             # <<<<<<<<<<<<<<
@@ -2826,7 +3008,7 @@
  */
     }
 
-    /* "professor2/core.pyx":133
+    /* "professor2/core.pyx":143
  * 
  *         ## Detect if the params have been passed as a single iterable and convert
  *         if len(params) == 1 and isinstance(params[0], collections.Iterable):             # <<<<<<<<<<<<<<
@@ -2835,39 +3017,39 @@
  */
   }
 
-  /* "professor2/core.pyx":140
+  /* "professor2/core.pyx":150
  * 
  *         ## Ensure that the param values are floats
  *         params = [float(p) for p in params]             # <<<<<<<<<<<<<<
  *         return  self._ptr.derivative(params)
  * 
  */
-  __pyx_t_5 = PyList_New(0); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = PyList_New(0); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_5);
   if (likely(PyList_CheckExact(__pyx_v_params)) || PyTuple_CheckExact(__pyx_v_params)) {
     __pyx_t_1 = __pyx_v_params; __Pyx_INCREF(__pyx_t_1); __pyx_t_3 = 0;
     __pyx_t_8 = NULL;
   } else {
-    __pyx_t_3 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_params); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_params); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_8 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_8 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
   for (;;) {
     if (likely(!__pyx_t_8)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_COMPILING_IN_CPYTHON
-        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       } else {
         if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_COMPILING_IN_CPYTHON
-        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       }
@@ -2877,7 +3059,7 @@
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         }
         break;
       }
@@ -2885,17 +3067,17 @@
     }
     __Pyx_XDECREF_SET(__pyx_v_p, __pyx_t_7);
     __pyx_t_7 = 0;
-    __pyx_t_9 = __Pyx_PyObject_AsDouble(__pyx_v_p); if (unlikely(__pyx_t_9 == ((double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_7 = PyFloat_FromDouble(__pyx_t_9); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_9 = __Pyx_PyObject_AsDouble(__pyx_v_p); if (unlikely(__pyx_t_9 == ((double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_7 = PyFloat_FromDouble(__pyx_t_9); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_7);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_5, (PyObject*)__pyx_t_7))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 140; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_5, (PyObject*)__pyx_t_7))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF_SET(__pyx_v_params, __pyx_t_5);
   __pyx_t_5 = 0;
 
-  /* "professor2/core.pyx":141
+  /* "professor2/core.pyx":151
  *         ## Ensure that the param values are floats
  *         params = [float(p) for p in params]
  *         return  self._ptr.derivative(params)             # <<<<<<<<<<<<<<
@@ -2903,20 +3085,20 @@
  *     ## Alias
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_10 = __pyx_convert_vector_from_py_double(__pyx_v_params); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_10 = __pyx_convert_vector_from_py_double(__pyx_v_params); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   try {
     __pyx_t_9 = __pyx_v_self->_ptr->derivative(__pyx_t_10);
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_t_5 = PyFloat_FromDouble(__pyx_t_9); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = PyFloat_FromDouble(__pyx_t_9); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":129
+  /* "professor2/core.pyx":139
  * 
  * 
  *     def derivative(self, *params):             # <<<<<<<<<<<<<<
@@ -2940,7 +3122,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":147
+/* "professor2/core.pyx":157
  * 
  * 
  *     def gradient(self, *params):             # <<<<<<<<<<<<<<
@@ -2989,37 +3171,37 @@
   __Pyx_RefNannySetupContext("gradient", 0);
   __Pyx_INCREF(__pyx_v_params);
 
-  /* "professor2/core.pyx":148
+  /* "professor2/core.pyx":158
  * 
  *     def gradient(self, *params):
  *         import collections             # <<<<<<<<<<<<<<
  * 
  *         ## Detect if the params have been passed as a single iterable and convert
  */
-  __pyx_t_1 = __Pyx_Import(__pyx_n_s_collections, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_Import(__pyx_n_s_collections, 0, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_collections = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "professor2/core.pyx":151
+  /* "professor2/core.pyx":161
  * 
  *         ## Detect if the params have been passed as a single iterable and convert
  *         if len(params) == 1 and isinstance(params[0], collections.Iterable):             # <<<<<<<<<<<<<<
  *             params = params[0]
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  */
-  __pyx_t_3 = PyObject_Length(__pyx_v_params); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = PyObject_Length(__pyx_v_params); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_t_4 = ((__pyx_t_3 == 1) != 0);
   if (__pyx_t_4) {
   } else {
     __pyx_t_2 = __pyx_t_4;
     goto __pyx_L4_bool_binop_done;
   }
-  __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_params, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_params, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_collections, __pyx_n_s_Iterable); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_collections, __pyx_n_s_Iterable); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_4 = PyObject_IsInstance(__pyx_t_1, __pyx_t_5); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = PyObject_IsInstance(__pyx_t_1, __pyx_t_5); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_t_6 = (__pyx_t_4 != 0);
@@ -3027,40 +3209,40 @@
   __pyx_L4_bool_binop_done:;
   if (__pyx_t_2) {
 
-    /* "professor2/core.pyx":152
+    /* "professor2/core.pyx":162
  *         ## Detect if the params have been passed as a single iterable and convert
  *         if len(params) == 1 and isinstance(params[0], collections.Iterable):
  *             params = params[0]             # <<<<<<<<<<<<<<
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  *             if isinstance(params, collections.Mapping):
  */
-    __pyx_t_5 = __Pyx_GetItemInt_Tuple(__pyx_v_params, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_5 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 152; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+    __pyx_t_5 = __Pyx_GetItemInt_Tuple(__pyx_v_params, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(__pyx_t_5 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 162; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF_SET(__pyx_v_params, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "professor2/core.pyx":154
+    /* "professor2/core.pyx":164
  *             params = params[0]
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  *             if isinstance(params, collections.Mapping):             # <<<<<<<<<<<<<<
  *                 params = params.values()
  * 
  */
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_collections, __pyx_n_s_Mapping); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_collections, __pyx_n_s_Mapping); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_2 = PyObject_IsInstance(__pyx_v_params, __pyx_t_5); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_2 = PyObject_IsInstance(__pyx_v_params, __pyx_t_5); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 164; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __pyx_t_6 = (__pyx_t_2 != 0);
     if (__pyx_t_6) {
 
-      /* "professor2/core.pyx":155
+      /* "professor2/core.pyx":165
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  *             if isinstance(params, collections.Mapping):
  *                 params = params.values()             # <<<<<<<<<<<<<<
  * 
  *         ## Ensure that the param values are floats
  */
-      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_params, __pyx_n_s_values); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_params, __pyx_n_s_values); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_1);
       __pyx_t_7 = NULL;
       if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_1))) {
@@ -3073,17 +3255,17 @@
         }
       }
       if (__pyx_t_7) {
-        __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_7); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_7); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
       } else {
-        __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 155; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 165; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       }
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __Pyx_DECREF_SET(__pyx_v_params, __pyx_t_5);
       __pyx_t_5 = 0;
 
-      /* "professor2/core.pyx":154
+      /* "professor2/core.pyx":164
  *             params = params[0]
  *             ## Further, detect if the params have been passed as a (ordered!) dict-like and extract the (ordered) values
  *             if isinstance(params, collections.Mapping):             # <<<<<<<<<<<<<<
@@ -3092,7 +3274,7 @@
  */
     }
 
-    /* "professor2/core.pyx":151
+    /* "professor2/core.pyx":161
  * 
  *         ## Detect if the params have been passed as a single iterable and convert
  *         if len(params) == 1 and isinstance(params[0], collections.Iterable):             # <<<<<<<<<<<<<<
@@ -3101,39 +3283,39 @@
  */
   }
 
-  /* "professor2/core.pyx":158
+  /* "professor2/core.pyx":168
  * 
  *         ## Ensure that the param values are floats
  *         params = [float(p) for p in params]             # <<<<<<<<<<<<<<
  *         return  self._ptr.gradient(params)
  * 
  */
-  __pyx_t_5 = PyList_New(0); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = PyList_New(0); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_5);
   if (likely(PyList_CheckExact(__pyx_v_params)) || PyTuple_CheckExact(__pyx_v_params)) {
     __pyx_t_1 = __pyx_v_params; __Pyx_INCREF(__pyx_t_1); __pyx_t_3 = 0;
     __pyx_t_8 = NULL;
   } else {
-    __pyx_t_3 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_params); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_params); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_8 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_8 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
   for (;;) {
     if (likely(!__pyx_t_8)) {
       if (likely(PyList_CheckExact(__pyx_t_1))) {
         if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_COMPILING_IN_CPYTHON
-        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_7 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       } else {
         if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
         #if CYTHON_COMPILING_IN_CPYTHON
-        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_7 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         #else
-        __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __pyx_t_7 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         __Pyx_GOTREF(__pyx_t_7);
         #endif
       }
@@ -3143,7 +3325,7 @@
         PyObject* exc_type = PyErr_Occurred();
         if (exc_type) {
           if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
         }
         break;
       }
@@ -3151,17 +3333,17 @@
     }
     __Pyx_XDECREF_SET(__pyx_v_p, __pyx_t_7);
     __pyx_t_7 = 0;
-    __pyx_t_9 = __Pyx_PyObject_AsDouble(__pyx_v_p); if (unlikely(__pyx_t_9 == ((double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-    __pyx_t_7 = PyFloat_FromDouble(__pyx_t_9); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_9 = __Pyx_PyObject_AsDouble(__pyx_v_p); if (unlikely(__pyx_t_9 == ((double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_7 = PyFloat_FromDouble(__pyx_t_9); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_7);
-    if (unlikely(__Pyx_ListComp_Append(__pyx_t_5, (PyObject*)__pyx_t_7))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (unlikely(__Pyx_ListComp_Append(__pyx_t_5, (PyObject*)__pyx_t_7))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF_SET(__pyx_v_params, __pyx_t_5);
   __pyx_t_5 = 0;
 
-  /* "professor2/core.pyx":159
+  /* "professor2/core.pyx":169
  *         ## Ensure that the param values are floats
  *         params = [float(p) for p in params]
  *         return  self._ptr.gradient(params)             # <<<<<<<<<<<<<<
@@ -3169,20 +3351,20 @@
  *     ## Alias
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_10 = __pyx_convert_vector_from_py_double(__pyx_v_params); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_10 = __pyx_convert_vector_from_py_double(__pyx_v_params); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   try {
     __pyx_t_11 = __pyx_v_self->_ptr->gradient(__pyx_t_10);
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_t_5 = __pyx_convert_vector_to_py_double(__pyx_t_11); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_5 = __pyx_convert_vector_to_py_double(__pyx_t_11); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_r = __pyx_t_5;
   __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":147
+  /* "professor2/core.pyx":157
  * 
  * 
  *     def gradient(self, *params):             # <<<<<<<<<<<<<<
@@ -3206,7 +3388,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":166
+/* "professor2/core.pyx":176
  * 
  * 
  *     def setParamLimits(self, pmins, pmaxs):             # <<<<<<<<<<<<<<
@@ -3246,11 +3428,11 @@
         case  1:
         if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_pmaxs)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("setParamLimits", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+          __Pyx_RaiseArgtupleInvalid("setParamLimits", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setParamLimits") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "setParamLimits") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
@@ -3263,7 +3445,7 @@
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("setParamLimits", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __Pyx_RaiseArgtupleInvalid("setParamLimits", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
   __pyx_L3_error:;
   __Pyx_AddTraceback("professor2.core.Ipol.setParamLimits", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
@@ -3286,23 +3468,23 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setParamLimits", 0);
 
-  /* "professor2/core.pyx":168
+  /* "professor2/core.pyx":178
  *     def setParamLimits(self, pmins, pmaxs):
  *         "Set the minimum and maximum param values via 2 lists ordered cf. the param names. Used in SVD internal scaling."
  *         self._ptr.setParamLimits(pmins, pmaxs)             # <<<<<<<<<<<<<<
  * 
  *     def minParamVals(self):
  */
-  __pyx_t_1 = __pyx_convert_vector_from_py_double(__pyx_v_pmins); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
-  __pyx_t_2 = __pyx_convert_vector_from_py_double(__pyx_v_pmaxs); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __pyx_convert_vector_from_py_double(__pyx_v_pmins); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __pyx_convert_vector_from_py_double(__pyx_v_pmaxs); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   try {
     __pyx_v_self->_ptr->setParamLimits(__pyx_t_1, __pyx_t_2);
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
 
-  /* "professor2/core.pyx":166
+  /* "professor2/core.pyx":176
  * 
  * 
  *     def setParamLimits(self, pmins, pmaxs):             # <<<<<<<<<<<<<<
@@ -3322,7 +3504,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":170
+/* "professor2/core.pyx":180
  *         self._ptr.setParamLimits(pmins, pmaxs)
  * 
  *     def minParamVals(self):             # <<<<<<<<<<<<<<
@@ -3354,7 +3536,7 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("minParamVals", 0);
 
-  /* "professor2/core.pyx":172
+  /* "professor2/core.pyx":182
  *     def minParamVals(self):
  *         "Get the minimum param values used in SVD internal scaling."
  *         return self._ptr.minParamVals()             # <<<<<<<<<<<<<<
@@ -3366,15 +3548,15 @@
     __pyx_t_1 = __pyx_v_self->_ptr->minParamVals();
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_t_2 = __pyx_convert_vector_to_py_double(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __pyx_convert_vector_to_py_double(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":170
+  /* "professor2/core.pyx":180
  *         self._ptr.setParamLimits(pmins, pmaxs)
  * 
  *     def minParamVals(self):             # <<<<<<<<<<<<<<
@@ -3393,7 +3575,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":173
+/* "professor2/core.pyx":183
  *         "Get the minimum param values used in SVD internal scaling."
  *         return self._ptr.minParamVals()
  *     def setMinParamVals(self, pmins):             # <<<<<<<<<<<<<<
@@ -3424,22 +3606,22 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setMinParamVals", 0);
 
-  /* "professor2/core.pyx":175
+  /* "professor2/core.pyx":185
  *     def setMinParamVals(self, pmins):
  *         "Set the minimum param values via a list of values ordered cf. the param names. Used in SVD internal scaling."
  *         self._ptr.setMinParamVals(pmins)             # <<<<<<<<<<<<<<
  * 
  *     def maxParamVals(self):
  */
-  __pyx_t_1 = __pyx_convert_vector_from_py_double(__pyx_v_pmins); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __pyx_convert_vector_from_py_double(__pyx_v_pmins); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   try {
     __pyx_v_self->_ptr->setMinParamVals(__pyx_t_1);
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 175; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
 
-  /* "professor2/core.pyx":173
+  /* "professor2/core.pyx":183
  *         "Get the minimum param values used in SVD internal scaling."
  *         return self._ptr.minParamVals()
  *     def setMinParamVals(self, pmins):             # <<<<<<<<<<<<<<
@@ -3459,7 +3641,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":177
+/* "professor2/core.pyx":187
  *         self._ptr.setMinParamVals(pmins)
  * 
  *     def maxParamVals(self):             # <<<<<<<<<<<<<<
@@ -3491,7 +3673,7 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("maxParamVals", 0);
 
-  /* "professor2/core.pyx":179
+  /* "professor2/core.pyx":189
  *     def maxParamVals(self):
  *         "Get the maximum param values used in SVD internal scaling."
  *         return self._ptr.maxParamVals()             # <<<<<<<<<<<<<<
@@ -3503,15 +3685,15 @@
     __pyx_t_1 = __pyx_v_self->_ptr->maxParamVals();
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_t_2 = __pyx_convert_vector_to_py_double(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __pyx_convert_vector_to_py_double(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":177
+  /* "professor2/core.pyx":187
  *         self._ptr.setMinParamVals(pmins)
  * 
  *     def maxParamVals(self):             # <<<<<<<<<<<<<<
@@ -3530,7 +3712,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":180
+/* "professor2/core.pyx":190
  *         "Get the maximum param values used in SVD internal scaling."
  *         return self._ptr.maxParamVals()
  *     def setMaxParamVals(self, pmaxs):             # <<<<<<<<<<<<<<
@@ -3561,22 +3743,22 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("setMaxParamVals", 0);
 
-  /* "professor2/core.pyx":182
+  /* "professor2/core.pyx":192
  *     def setMaxParamVals(self, pmaxs):
  *         "Set the maximum param values via a list of values ordered cf. the param names. Used in SVD internal scaling."
  *         self._ptr.setMaxParamVals(pmaxs)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __pyx_convert_vector_from_py_double(__pyx_v_pmaxs); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __pyx_convert_vector_from_py_double(__pyx_v_pmaxs); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   try {
     __pyx_v_self->_ptr->setMaxParamVals(__pyx_t_1);
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
 
-  /* "professor2/core.pyx":180
+  /* "professor2/core.pyx":190
  *         "Get the maximum param values used in SVD internal scaling."
  *         return self._ptr.maxParamVals()
  *     def setMaxParamVals(self, pmaxs):             # <<<<<<<<<<<<<<
@@ -3596,7 +3778,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":185
+/* "professor2/core.pyx":195
  * 
  * 
  *     def toString(self, name=""):             # <<<<<<<<<<<<<<
@@ -3636,7 +3818,7 @@
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "toString") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "toString") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 195; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
@@ -3649,7 +3831,7 @@
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("toString", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __Pyx_RaiseArgtupleInvalid("toString", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 195; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
   __pyx_L3_error:;
   __Pyx_AddTraceback("professor2.core.Ipol.toString", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
@@ -3673,7 +3855,7 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("toString", 0);
 
-  /* "professor2/core.pyx":187
+  /* "professor2/core.pyx":197
  *     def toString(self, name=""):
  *         "Produce a persistent string representing this Ipol object"
  *         return self._ptr.toString(name)             # <<<<<<<<<<<<<<
@@ -3681,20 +3863,20 @@
  *     def __repr__(self):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_convert_string_from_py_std__in_string(__pyx_v_name); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __pyx_convert_string_from_py_std__in_string(__pyx_v_name); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   try {
     __pyx_t_2 = __pyx_v_self->_ptr->toString(__pyx_t_1);
   } catch(...) {
     __Pyx_CppExn2PyErr();
-    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
-  __pyx_t_3 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 187; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = __pyx_convert_PyBytes_string_to_py_std__in_string(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 197; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":185
+  /* "professor2/core.pyx":195
  * 
  * 
  *     def toString(self, name=""):             # <<<<<<<<<<<<<<
@@ -3713,7 +3895,7 @@
   return __pyx_r;
 }
 
-/* "professor2/core.pyx":189
+/* "professor2/core.pyx":199
  *         return self._ptr.toString(name)
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
@@ -3746,15 +3928,15 @@
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__repr__", 0);
 
-  /* "professor2/core.pyx":190
+  /* "professor2/core.pyx":200
  * 
  *     def __repr__(self):
  *         return self.toString(self.name)             # <<<<<<<<<<<<<<
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_toString); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_toString); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_name); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_name); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
@@ -3767,17 +3949,17 @@
     }
   }
   if (!__pyx_t_4) {
-    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else {
-    __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_t_3);
     __pyx_t_3 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
@@ -3786,7 +3968,7 @@
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "professor2/core.pyx":189
+  /* "professor2/core.pyx":199
  *         return self._ptr.toString(name)
  * 
  *     def __repr__(self):             # <<<<<<<<<<<<<<
@@ -4791,7 +4973,7 @@
   {0, 0, 0, 0, 0, 0, 0}
 };
 static int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_property = __Pyx_GetBuiltinName(__pyx_n_s_property); if (!__pyx_builtin_property) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_property = __Pyx_GetBuiltinName(__pyx_n_s_property); if (!__pyx_builtin_property) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 68; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   return 0;
   __pyx_L1_error:;
@@ -4845,6 +5027,7 @@
 
 static int __Pyx_InitGlobals(void) {
   if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   return 0;
   __pyx_L1_error:;
   return -1;
@@ -4977,187 +5160,187 @@
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_numCoeffs, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 13; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "professor2/core.pyx":73
+  /* "professor2/core.pyx":83
  * 
  *     @property
  *     def coeffs(self):             # <<<<<<<<<<<<<<
  *         return self._ptr.coeffs()
  * 
  */
-  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_coeffs); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 73; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_coeffs); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 83; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
 
-  /* "professor2/core.pyx":72
+  /* "professor2/core.pyx":82
  * 
  * 
  *     @property             # <<<<<<<<<<<<<<
  *     def coeffs(self):
  *         return self._ptr.coeffs()
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 72; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 82; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_coeffs, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 73; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_coeffs, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 83; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_10professor2_4core_Ipol);
 
-  /* "professor2/core.pyx":77
+  /* "professor2/core.pyx":87
  * 
  *     @property
  *     def structure(self):             # <<<<<<<<<<<<<<
  *         #rtn = []
  *         return self._ptr.structure()
  */
-  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_structure); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 77; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_structure); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
 
-  /* "professor2/core.pyx":76
+  /* "professor2/core.pyx":86
  *         return self._ptr.coeffs()
  * 
  *     @property             # <<<<<<<<<<<<<<
  *     def structure(self):
  *         #rtn = []
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 76; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 76; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_structure, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 77; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_structure, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_10professor2_4core_Ipol);
 
-  /* "professor2/core.pyx":85
+  /* "professor2/core.pyx":95
  * 
  *     @property
  *     def dim(self):             # <<<<<<<<<<<<<<
  *         return self._ptr.dim()
  * 
  */
-  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_dim); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_dim); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 95; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
 
-  /* "professor2/core.pyx":84
+  /* "professor2/core.pyx":94
  *         return self._ptr.longVector(params)
  * 
  *     @property             # <<<<<<<<<<<<<<
  *     def dim(self):
  *         return self._ptr.dim()
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 84; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 84; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_dim, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_dim, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 95; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_10professor2_4core_Ipol);
 
-  /* "professor2/core.pyx":89
+  /* "professor2/core.pyx":99
  * 
  *     @property
  *     def order(self):             # <<<<<<<<<<<<<<
  *         return self._ptr.order()
  * 
  */
-  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_order); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 89; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_order); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
 
-  /* "professor2/core.pyx":88
+  /* "professor2/core.pyx":98
  *         return self._ptr.dim()
  * 
  *     @property             # <<<<<<<<<<<<<<
  *     def order(self):
  *         return self._ptr.order()
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 88; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 98; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 88; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 98; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_order, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 89; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_order, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_10professor2_4core_Ipol);
 
-  /* "professor2/core.pyx":93
+  /* "professor2/core.pyx":103
  * 
  *     @property
  *     def name(self):             # <<<<<<<<<<<<<<
  *         return self._ptr.name()
  * 
  */
-  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 93; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
 
-  /* "professor2/core.pyx":92
+  /* "professor2/core.pyx":102
  *         return self._ptr.order()
  * 
  *     @property             # <<<<<<<<<<<<<<
  *     def name(self):
  *         return self._ptr.name()
  */
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 92; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
   __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 92; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_property, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 102; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_name, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 93; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_name, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_10professor2_4core_Ipol);
 
-  /* "professor2/core.pyx":126
+  /* "professor2/core.pyx":136
  * 
  *     ## Alias
  *     val = value             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_value); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_value); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_val, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_val, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_10professor2_4core_Ipol);
 
-  /* "professor2/core.pyx":144
+  /* "professor2/core.pyx":154
  * 
  *     ## Alias
  *     der = derivative             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_derivative); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_derivative); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_der, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_der, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 154; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_10professor2_4core_Ipol);
 
-  /* "professor2/core.pyx":162
+  /* "professor2/core.pyx":172
  * 
  *     ## Alias
  *     grad = gradient             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_gradient); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_GetNameInClass((PyObject *)__pyx_ptype_10professor2_4core_Ipol, __pyx_n_s_gradient); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_grad, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 162; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (PyDict_SetItem((PyObject *)__pyx_ptype_10professor2_4core_Ipol->tp_dict, __pyx_n_s_grad, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_ptype_10professor2_4core_Ipol);
 
diff -uNr Professor-2.2.2/pyext/professor2/core.pyx Professor-2.2.2_mod/pyext/professor2/core.pyx
--- Professor-2.2.2/pyext/professor2/core.pyx	2017-11-13 15:32:46.000000000 +0100
+++ Professor-2.2.2_mod/pyext/professor2/core.pyx	2018-01-05 14:43:41.402182180 +0100
@@ -50,17 +50,27 @@
             pp = ParamPoints(args[0])
             vals = list(args[1])
             order = int(args[2])
-            name = ""
-            threshold = 1e-40 #< ???
-            if len(args) == 4:
-                try:
-                    threshold = float(args[3])
-                except:
-                    name = str(args[3])
-            if len(args) == 5:
+            if order < 0:
+                errs = list(args[3])
+                bin_num = int(args[4])
+                histname = str(args[5])
+                doipol = bool(args[6])
+                order = int(args[7])
+                fitparams = list(args[8])
+                config = str(args[9])
+                self._ptr = new c.Ipol(deref(pp._ptr), vals, errs, bin_num, histname, doipol, order, fitparams, config)
+            else:
+                name = ""
+                threshold = 1e-40 #< ???
+                if len(args) == 4:
+                    try:
+                        threshold = float(args[3])
+                    except:
+                        name = str(args[3])
+                if len(args) == 5:
                     name = str(args[3])
                     threshold = float(args[4])
-            self._ptr = new c.Ipol(deref(pp._ptr), vals, order, name, threshold, True)
+                self._ptr = new c.Ipol(deref(pp._ptr), vals, order, name, threshold, True)
 
     def __del__(self):
         del self._ptr
Binary files Professor-2.2.2/pyext/professor2/core.so and Professor-2.2.2_mod/pyext/professor2/core.so differ
diff -uNr Professor-2.2.2/pyext/professor2/ipol.py Professor-2.2.2_mod/pyext/professor2/ipol.py
--- Professor-2.2.2/pyext/professor2/ipol.py	2017-11-13 15:32:46.000000000 +0100
+++ Professor-2.2.2_mod/pyext/professor2/ipol.py	2018-01-05 15:38:09.792324769 +0100
@@ -22,7 +22,7 @@
     return runs, paramnames, paramslist
 
 
-def mk_ipolbin(rawP, rawV, rawE, xmin, xmax, CFG):
+def mk_ipolbin(rawP, rawV, rawE, xmin, xmax, CFG, n = 0, hn = ""):
     # TODO finally learn how to use kwargs
     order    = CFG["ORDER"]
     errorder = CFG["ERR_ORDER"]
@@ -53,6 +53,13 @@
 
     if order == "auto":
         valipol =mk_autoipol(P, V, CFG)
+    elif order < 0:
+        valipol = Ipol(P, V, int(order), E, n, hn, True, 0, [0], "")
+        if errorder == -1:
+            erripols = Ipol(P, V, int(order), E, n, hn, False, valipol.order(), valipol.coeffs(), "")
+            return IpolBin(xmin, xmax, valipol, erripols), pmin, pmax
+        else:
+			errororder = valipol.order()
     else:
         valipol = Ipol(P, V, int(order))
 
@@ -249,7 +256,7 @@
                     CFG["ERR_ORDER"]=temp[3]
                     ib, pmin, pmax = prof.mk_ipolbin(PARAMSLIST, vals, errs, xmin, xmax, CFG)
                 else:
-                    ib, pmin, pmax = prof.mk_ipolbin(PARAMSLIST, vals, errs, xmin, xmax, CFG)
+                    ib, pmin, pmax = prof.mk_ipolbin(PARAMSLIST, vals, errs, xmin, xmax, CFG, n, hn)
                 s = ""
                 s += "%s#%d %.5e %.5e\n" % (hn, n, ib.xmin, ib.xmax)
                 s += "  " + ib.ival.toString("val")
diff -uNr Professor-2.2.2/pyext/professor2/professor.pxd Professor-2.2.2_mod/pyext/professor2/professor.pxd
--- Professor-2.2.2/pyext/professor2/professor.pxd	2017-11-13 15:32:46.000000000 +0100
+++ Professor-2.2.2_mod/pyext/professor2/professor.pxd	2018-01-05 14:37:05.135124883 +0100
@@ -21,6 +21,7 @@
     cdef cppclass Ipol:
 
         Ipol(const ParamPoints& p, const vector[double]&, int, const string&, double, bool) except +
+        Ipol(ParamPoints&, const vector[double]&, const vector[double]&, int&, const string&, bool, int&, vector[double]&, const string&) except +
         Ipol(const string&) except +
 
         string name() except +
diff -uNr Professor-2.2.2/pyext/professor2/professor.pxd~ Professor-2.2.2_mod/pyext/professor2/professor.pxd~
--- Professor-2.2.2/pyext/professor2/professor.pxd~	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/pyext/professor2/professor.pxd~	2017-11-13 15:32:46.000000000 +0100
@@ -0,0 +1,50 @@
+from libcpp.map cimport map
+from libcpp.pair cimport pair
+from libcpp.vector cimport vector
+from libcpp cimport bool
+from libcpp.string cimport string
+
+
+cdef extern from "Professor/Professor.h" namespace "Professor":
+    string version()
+
+cdef extern from "Professor/Ipol.h" namespace "Professor":
+    int numCoeffs(int dim, int order)
+
+
+cdef extern from "Professor/ParamPoints.h" namespace "Professor":
+    cdef cppclass ParamPoints:
+        ParamPoints(const vector[vector[double]]&) except +
+
+
+cdef extern from "Professor/Ipol.h" namespace "Professor":
+    cdef cppclass Ipol:
+
+        Ipol(const ParamPoints& p, const vector[double]&, int, const string&, double, bool) except +
+        Ipol(const string&) except +
+
+        string name() except +
+        int order() except +
+        int dim() except +
+
+        const vector[double]& coeffs() except +
+        const double& coeff(size_t) except +
+
+        const vector[vector[int]]& structure() except +
+        vector[double] longVector(const vector[double]&) except +
+
+        const ParamPoints& params() except +
+
+        double value(const vector[double]&) except +
+
+        double derivative(const vector[double]&) except +
+        const vector[double] gradient(const vector[double]&) except +
+
+        string toString() except +
+        string toString(const string&) except +
+
+        const vector[double]& minParamVals() except +
+        const vector[double]& maxParamVals() except +
+        void setParamLimits(const vector[double]&, const vector[double]&) except +
+        void setMinParamVals(const vector[double]&) except +
+        void setMaxParamVals(const vector[double]&) except +
diff -uNr Professor-2.2.2/src/ConfigHandler.cc Professor-2.2.2_mod/src/ConfigHandler.cc
--- Professor-2.2.2/src/ConfigHandler.cc	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/src/ConfigHandler.cc	2017-11-28 13:03:19.978614000 +0100
@@ -0,0 +1,114 @@
+#include "Professor/ConfigHandler.h"
+
+/**
+ * Constructor that reads a config file and sets all member variables according to the file
+ * @configfile: name of the config file
+ * @ifile: input stream for reading the config file
+ * @line: string that gets the content of a line in the configfile
+ */
+ConfigHandler::ConfigHandler(const string configfile){
+	
+	if(!configfile.empty()){
+		cout << "reading config file ...";
+		ifstream ifile;
+		ifile.open(configfile);
+		string line;
+		
+		if(ifile.is_open())
+		{
+			//linewise file reading
+			while(getline(ifile, line))
+			{
+				//checking for signal words and calling the respective function
+				if(line.substr(0, 12) == "thresholdfit")
+					readThresholdFit(line);
+					
+				if(line.substr(0, 13) == "thresholddata")
+					readThresholdData(line);
+					
+				if(line.substr(0, 12) == "thresholderr")
+					readThresholdErr(line);
+					
+				if(line.substr(0, 8) == "chi2mean")
+					readChi2Mean(line);
+					
+				if(line.substr(0, 5) == "kappa")
+					readKappa(line);
+					
+				if(line.substr(0, 7) == "summary")
+					readSummaryFlag(line);
+					
+				if(line.substr(0, 6) == "outdot")
+					readOutDotFlag(line);
+					
+				if(line.substr(0, 6) == "covmat")
+					readCovMat(line);
+			}		
+		}
+		cout << "complete" << endl;
+	}
+}
+
+/**
+ * This function reads the threshold of the RR constrain of the fit
+ * @line: contains the threshold value
+ */
+void ConfigHandler::readThresholdFit(const string line){
+		_thresholdfit = atof(line.substr(13).c_str());
+}
+
+/**
+ * This function reads the threshold of the RR constrain of the hypercube fitting
+ * @line: contains the threshold value
+ */
+void ConfigHandler::readThresholdData(const string line){
+		_thresholddata = atof(line.substr(14).c_str());	
+}
+
+/**
+ * This function reads the threshold of the RR constrain of the error of the fit
+ * @line: contains the threshold value
+ */
+void ConfigHandler::readThresholdErr(const string line){
+		_thresholderr = atof(line.substr(13).c_str());	
+}
+
+/**
+ * This function reads the number of Chi2 values used for the mean calculation
+ * @line: contains the number of points
+ */
+void ConfigHandler::readChi2Mean(const string line){
+		_chi2mean = atof(line.substr(9).c_str());	
+}
+
+/**
+ * This function reads the kappa of the RR constrain
+ * @line: contains the value
+ */
+void ConfigHandler::readKappa(const string line){
+		_kappa = atof(line.substr(6).c_str());
+}
+
+/**
+ * This function reads the flag for writing the summary output
+ * @line: contains the value
+ */
+void ConfigHandler::readSummaryFlag(const string line){
+	_summaryflag = atoi(line.substr(8).c_str());	
+}
+
+/**
+ * This function reads the flag for writing the dot product summary
+ * @line: contains the value
+ */
+void ConfigHandler::readOutDotFlag(const string line){
+	_outdotflag = atoi(line.substr(7).c_str());
+}
+
+/**
+ * This function reads the flag for writing the covariance matrices
+ * @line: string that contains the flag
+ */
+void ConfigHandler::readCovMat(const string line){
+	_covmat = atoi(line.substr(7).c_str());
+}
diff -uNr Professor-2.2.2/src/Counter.cc Professor-2.2.2_mod/src/Counter.cc
--- Professor-2.2.2/src/Counter.cc	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/src/Counter.cc	2017-11-27 11:37:21.810094000 +0100
@@ -0,0 +1,42 @@
+#include "Professor/Counter.h"
+
+//Destructor
+Counter::~Counter(void) { }
+
+/**
+ * This function calculates a new step in order to calculate the powers for a monomial.
+ * The idea is a list of powers, starting at [0, 0, ... ,0], that will be increased in every step
+ * until it fits the needed order. Starting with the last index, the value of an index gets increased by 1.
+ * If the index is at the maximum, it will be resetted to 0 and the next index will be increased
+ * in a recursive way.
+ * That way, every possible combination of powers in a certain order can be calculated.
+ * @index: this is the parameter, that will be modified
+ */
+const bool Counter::next(const int index) {
+	//if the index is at the maximum...
+	if (_data[index] == _maxval) {
+		//if the first index is at his maximum, the function returns false in order to break an outer for-loop
+		//this condition means that every combination was created
+		if(index == 0) return false;
+		//...the index will be resetted and the next index will be calculated
+		_data[index] = 0;
+		return next(index - 1);
+	}
+	else {
+		//If the entry is smaller than the maximum, it will be increased.
+		//the return value is meant as continuitation of an outer for-loop
+		_data[index]++;
+		return true;
+	}
+}
+
+/**
+ * This function calculates the sum of all powers in @_data
+ * @sum_v: storage for the sum
+ */
+const int Counter::sum() const{
+	int sum_v = 0;
+	for (size_t n = 0; n < _data.size(); n++)
+	  sum_v += _data[n];
+	return sum_v;
+}
diff -uNr Professor-2.2.2/src/FitHandler.cc Professor-2.2.2_mod/src/FitHandler.cc
--- Professor-2.2.2/src/FitHandler.cc	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/src/FitHandler.cc	2017-11-30 11:40:47.353437000 +0100
@@ -0,0 +1,312 @@
+#include "Professor/FitHandler.h"
+
+/**
+ * Constructor
+ * This constructor is used for an interpolation
+ */
+FitHandler::FitHandler(){}
+
+/**
+ * Constructor
+ * This constructor is used for the calculation of the uncertainty of the fit parameters of a previously performed fit
+ * @fitparams: vector that contains the fitparameters
+ * @pterrs: vector that contains the uncertainties of the data
+ * @pts: Object that contains every information about the anchor points
+ * @order: order of the polynomial function
+ * @num_ipol: bin number
+ */
+FitHandler::FitHandler(const vector<double>& fitparams, const vector<double>& pterrs, Professor::ParamPoints& pts, const int order, const int num_ipol, const string histname){
+
+	//local storage of parameters
+	_bfp = fitparams;
+	_sigma = pterrs;
+	_qrh.load(order, pts, getNumFitParams());
+
+	//calculate the fit errors
+	setFitErrors(num_ipol, histname);
+	_bfp = _bfperr;
+	_bfperr.clear();
+}
+
+/**
+ * This function rescales the best fit parameters caused by the normalization of @_m and @_b
+ */
+void FitHandler::rescaleBestFitParameters(){
+	//backwards calculating of the norms that influenzed @_m and @_b in order to get the regular best fit parameters
+	for(size_t i = 0; i < _bfp.size(); i++)
+		_bfp[i] *= LinAlg::getAbs(_qrh.getB()) / LinAlg::getAbs(LinAlg::getCol(_qrh.getM(), i));
+}
+
+/**
+ * This function calculates the Chi^2 value of the fit.
+ * @result: resulting Chi^2
+ * @functionvalue: functionvalue of the fit at a certain point
+ */
+const double FitHandler::getChi2() const{
+
+	double result = 0, functionvalue = 0;
+	//walk over every polynomial
+	for(size_t i = 0; i < _qrh.getM().size(); i++)
+	{
+		//if the bin entry is 0, it can be a simple misscalculation in Rivet etc.
+		if(_qrh.getB()[i] == 0)
+			continue;
+		
+		for(size_t j = 0; j < _qrh.getM()[i].size(); j++)
+			functionvalue += _qrh.getM()[i][j] * _bfp[j];
+			
+		//get the difference between the functionvalue and the datapoint		
+		functionvalue -= _qrh.getB()[i];
+		
+		//if the uncertainty is 0, the calculation would rise a nan
+		//this is prevented by setting it to the arbitrary value of 1e-10
+		if(_sigma[i] == 0)
+			result += (functionvalue * functionvalue) / (1e-10 * 1e-10);
+		else
+			result += (functionvalue * functionvalue) / (_sigma[i] * _sigma[i]);
+		functionvalue = 0;
+	}
+	return result;
+}
+
+/**
+ * This function returns Dsmooth
+ * @pts: container of the anchor points
+ * @result: result of the calculation that will be returned
+ */
+const double FitHandler::getDsmooth(Professor::ParamPoints& pts){
+
+	//check, if the smoothness was already calculated within this iteration
+	if(_dsmooth_current == 2)
+	{
+		double result = 0;
+		//walking over all anchor points and adding the dotproduct of the gradient vectors
+		for(size_t i = 0; i < pts.numPoints(); i++)
+			result += LinAlg::dotProduct(pts.getGradient(i), _gc.getGradVector(i, _bfp, pts, getMaxPower()));
+		_dsmooth_current = result / (double) pts.numPoints();
+	}
+	//returning the mean
+	return _dsmooth_current;
+}
+
+/**
+ * This function calculates the uncertainty of the fit parameters.
+ * @num_ipol: number of the bin
+ * @mat: storage of the precision matrix, later of the covariance matrix
+ * @tmp: temporary storage of the elements of the precision matrix
+ * @oh: object that handles the writing of the result to file
+ */
+void FitHandler::setFitErrors(const size_t num_ipol, const string histname){
+
+	MatrixXd mat(_bfp.size(), _bfp.size());
+	double tmp;
+	//fill the matrix; walking over the upper triangle
+	for(size_t row = 0; row < _bfp.size(); row++)
+		for(size_t col = row; col < _bfp.size(); col++)
+		{	
+			//pull an element
+			tmp = getInvCovMatElement(row, col);
+			if(row == col)
+				//if the element is on the diagonal then set it
+				mat(row, col) = tmp;
+			else
+			{
+				//using the symmetry, setting off-diagonal elements twice
+				mat(row, col) = tmp;
+				mat(col, row) = tmp;
+			}
+		}
+
+	//calculating the inverse of the matrix
+	mat = mat.fullPivHouseholderQr().inverse();
+
+	//if an element is +/-infinity, it will be set to the maximum/minimum of double instead
+	for(size_t i = 0; i < _bfp.size(); i++)
+		if(mat(i, i) == std::numeric_limits<double>::infinity())
+			_bfperr.push_back(std::numeric_limits<double>::max());
+		else
+			if(-mat(i, i) == std::numeric_limits<double>::infinity())
+				_bfperr.push_back(-std::numeric_limits<double>::max());
+			else
+				_bfperr.push_back(sqrt(fabs(mat(i, i))));
+	
+	//writing the covariance matrix to file
+	OutputHandler oh;
+	oh.writeCovMat(mat, num_ipol, histname);
+}
+
+/**
+ * This function calculates an element of the precision matrix
+ * @i, @j: row/column of the matrix
+ * @result: value of the matrix element
+ */
+const double FitHandler::getInvCovMatElement(const size_t i, const size_t j) const{
+	double result = 0;
+
+	//walk over the fit function
+	for(size_t k = 0; k < _qrh.getM().size(); k++)
+	{ 
+		//If the uncertainty is zero, the result would be inf. Those elements will be skipped. It does not change the overall result, since it will be left out for every element.
+		if(_sigma[k] == 0)
+			continue;		
+		//bin wise calculating d^2\chi^2/da_ida_j with the fit parameters \vec{a}
+		result += _qrh.getM()[k][i] * _qrh.getM()[k][j] / (_sigma[k] * _sigma[k]);	
+	}
+	return result;
+}
+
+/**
+ * This function calculates the next iteration in a bin
+ * @pts: container of the anchor points
+ * @threshold: threshold of the RR constraint of the fit
+ * @kappa: shift in case of applied RR constraint
+ */
+void FitHandler::nextStep(Professor::ParamPoints& pts, const double threshold, const double kappa){
+	
+	_gc.initStructure(pts);
+	//reset the smoothness, so that will be calculated again
+	_dsmooth_current = 2;
+	
+	//perform the iteration
+	_qrh.iterate(pts);
+	_a.resize(_qrh.getM()[0].size());
+	LinAlg::collinearity(_a, _qrh.getR(), _qrh.getB(), threshold, kappa);
+	
+	//getting the fit and rescale it
+	_bfp = LinAlg::getBestFitParameters(_qrh.getR(), _a, _qrh.getBprime());	
+	
+	rescaleBestFitParameters();
+}
+
+/**
+ * This function sets initializes the object for a new bin
+ * @pts: container of the anchor points
+ * @ptvals: bin values of each anchor point
+ * @pterrs: uncertainty of the bin values of each anchor point
+ * @num_ipol: number of the bin
+ * @threshold: threshold of the RR constraint of the fit
+ * @kappa: shift in case of applied RR constraint
+ */
+void FitHandler::startBin(Professor::ParamPoints& pts, const vector<double>& ptvals, const vector<double>& pterrs, const double threshold, const double kappa){
+	//set up object + 1st iteration
+	_sigma = pterrs;
+	_qrh.init(pts, ptvals);
+	_a.resize(_qrh.getM()[0].size());
+	
+	LinAlg::collinearity(_a, _qrh.getR(), _qrh.getB(), threshold, kappa);
+	
+	//getting the fit and rescaling it
+	_bfp = LinAlg::getBestFitParameters(_qrh.getR(), _a, _qrh.getBprime());
+	rescaleBestFitParameters();	
+}
+
+/**
+ * This function is a getter of the number of fit parameters
+ * @zeros: counter of 0's as fit parameters
+ */
+const size_t FitHandler::getNumFitParams() const{
+	size_t zeros = 0;
+
+	//count the number of 0's at the end of the fit parameters list
+	for(size_t i = _bfp.size(); i > 0; i--)
+		if(_bfp[i - 1] == 0)
+			zeros++;
+		else
+			break;
+		
+	//return the number of fit parameters that are != 0	
+	return _bfp.size() - zeros;
+}
+
+/**
+ * This function sets the object up for a certain bin and calculates a given number of iterations
+ * @pts: container of the anchor points
+ * @ptvals: bin values of each anchor point
+ * @pterrs: error of the bin values of each anchor point
+ * @num_ipol: number of the bin
+ * @threshold: threshold of the RR constraint of the fit
+ * @kappa: shift in case of an applied RR constraint
+ * @bestiteration: number of iterations that will be performed
+ */
+void FitHandler::setToIteration(Professor::ParamPoints& pts, const vector<double>& ptvals, const vector<double>& pterrs, const int num_ipol, const double threshold, const double kappa, const int bestiteration){
+
+	//reset
+	_bfp.clear();
+	_bfperr.clear();
+	_qrh.reset();
+	_d.clear();
+	_a.clear();
+	//setting up the bin
+	startBin(pts, ptvals, pterrs, threshold, kappa);
+	if(bestiteration > 0)
+	{
+		//Fast walking the number of iterations along.
+		while(_qrh.getIterationCounter() < bestiteration - 1)
+			_qrh.iterate(pts, true);
+		
+		//Perform the whole calculation only for the last step. That way the Object is indifferent to a regular stepping.
+		nextStep(pts, threshold, kappa);
+	}	
+}
+
+/**
+ * This function calculates the dot product of all normalized gradients at each anchor point with each other
+ * @pts: container of the anchor points
+ * @result: vector containing all dot products
+ * @tmp: temporary storage of the gradient vectors
+ */
+const vector<double> FitHandler::getAllGradDotProducts(Professor::ParamPoints& pts){
+	
+	vector<double> result;
+	vector<vector<double>> tmp;
+	tmp.resize(pts.numPoints());
+	
+	//walk over every possible combination of anchor points
+	for(size_t i = 0; i < pts.numPoints(); i++)
+	{
+		//if a gradient was not calculated yet, do it
+		if(tmp[i].empty())
+			tmp[i] = _gc.getGradVector(i, _bfp, pts, getMaxPower());
+		for(size_t j = 0; j < pts.numPoints(); j++)
+		{
+			//if a gradient was not calculated yet, do it
+			if(tmp[j].empty())
+				tmp[j] = _gc.getGradVector(j, _bfp, pts, getMaxPower());
+			//only calculate the dot product, if the points aren't the same
+			if(i != j)
+				result.push_back(LinAlg::dotProduct(tmp[i], tmp[j]));
+		}
+	}
+	return result;
+}
+
+/**
+ * This function adds 0's to the list of fit parameters and their uncertainties in order to fill up a certain order. Afterwards, the parameters will be reordered for Professor 2.2.1 usage.
+ * That is needed in order to become usable for Professor 2.2.1.
+ * @match_index: mapping list that connects the current order to the order needed by Professor 2.2.1
+ * @bfp_sorted, @bfperr_sorted: helper to store the new ordering 
+ */
+void FitHandler::sortFitParams(const vector<int>& match_index){
+	
+	//push back 0's until there are enough 0's that it matches a certain polynomial order
+    for(size_t i = _bfp.size(); i < _qrh.getPower().size(); i++)
+		_bfp.push_back(0);
+	for(size_t i = _bfperr.size(); i < _qrh.getPower().size(); i++)
+		_bfperr.push_back(0);
+
+	//set up the helper
+	vector<double> bfp_sorted, bfperr_sorted;
+	bfp_sorted.resize(_bfp.size());
+	bfperr_sorted.resize(_bfperr.size());
+	
+	//filling the helper
+	for(size_t i = 0; i < match_index.size(); i++)
+	{
+		bfp_sorted[i] = _bfp[match_index[i]];
+		bfperr_sorted[i] = _bfperr[match_index[i]];
+	}
+	
+	//set the ordered list as the entries of the member variables
+	_bfp = bfp_sorted;
+	_bfperr = bfperr_sorted;
+}
diff -uNr Professor-2.2.2/src/GradCalc.cc Professor-2.2.2_mod/src/GradCalc.cc
--- Professor-2.2.2/src/GradCalc.cc	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/src/GradCalc.cc	2017-11-27 15:49:02.602959000 +0100
@@ -0,0 +1,130 @@
+#include "Professor/GradCalc.h"
+
+/**
+ * This functions sets up @_structure.
+ * @pts: Storage of all anchor points
+ */
+void GradCalc::initStructure(const Professor::ParamPoints& pts){
+	if(_structure.empty())
+	{
+			_structure.resize(pts.numPoints());
+			for(size_t j = 0; j < pts.numPoints(); j++)
+				_structure[j].resize(pts.dim());
+	}	
+}
+
+/**
+ * This function calculates the fit parameter independent part of a monomial of a gradient vector
+ * @i: bin number
+ * @j: dimension
+ * @k: monomial
+ * @pts: storage of the anchor points and powers
+ * @order: order of the polynomial function
+ * @tmp: storage of the value of the fit parameter independent part of the monomial
+ */
+const double GradCalc::addMonomial(const size_t i, const size_t j, const size_t k, Professor::ParamPoints& pts, const int order){
+
+	double tmp = 1;
+	//extracting the respective parameter values
+	for(size_t l = 0; l < pts.dim(); l++)
+		//if the parameter is the one that is derived in the component of the gradient, then its derivative is used
+		if(j == l)
+			//if the value of the parameter is 0 & the power of the parameter to derive is != 1, the whole monomial will be 0 but the special case in the derivative of 0^0 = 1
+			//if the power is 0, the whole monomial will be 0 after derived 
+			if((pts.pointScaled(i)[l] == 0 && pts.getPower(order)[k][l] != 1) || pts.getPower(order)[k][l] == 0)
+			{	
+				tmp = 0;
+				continue;
+			}							
+			else			
+				//multiply the derived factor
+				tmp *= pow(pts.pointScaled(i)[l], pts.getPower(order)[k][l] - 1) * pts.getPower(order)[k][l];	
+		else
+			//if at least one of the not derived parameters is 0 and its power is !=0, the whole monomial become 0
+			if(pts.pointScaled(i)[l] == 0 && pts.getPower(order)[k][l] != 0)
+			{
+				tmp = 0;
+				continue;
+			}
+			else
+				tmp *= pow(pts.pointScaled(i)[l], pts.getPower(order)[k][l]);
+	return tmp;
+}
+
+/**
+ * This function adds new terms to @_structre
+ * @i: bin number
+ * @j: dimension
+ * @numFitParams: number of fit parameters in the polynomial function
+ * @pts: storage of the anchor points and powers
+ * @order: order of the polynomial function
+ * @tmpstruc: temporary storage of the new parts of @_structure
+ */
+void GradCalc::extendStructure(const size_t i, const size_t j, const size_t numFitParams, Professor::ParamPoints& pts, const int order){
+
+	vector<double> tmpstruc = _structure[i][j];
+	tmpstruc.resize(numFitParams);
+
+	//start the calculation after the last calculated component and walk up to the new maximum needed
+	for(size_t k = _structure[i][j].size(); k < tmpstruc.size(); k++)
+		//put the new monomial part to the @tmpstruc at the specific point in the list
+		tmpstruc[k] = addMonomial(i, j, k, pts, order);
+
+	//store the result in @_structure
+	setStructure(i, j, tmpstruc);	
+}
+
+/**
+ * This function serves as a getter of a gradient vector. If the vector is not available yet it will be calculated.
+ * @i: bin number
+ * @bfp: fit parameters
+ * @pts: storage of the anchor points and powers
+ * @order: order of the polynomial function
+ * @functiongradient: vector that contains the value of the gradient evaluated at the @i-th anchor point
+ */
+const vector<double> GradCalc::getGradVector(const size_t i, const vector<double>& bfp, Professor::ParamPoints& pts, const int order){
+	
+	//Initialize
+	initStructure(pts);
+	vector<double> functiongradient;
+	functiongradient.assign(_structure[0].size(), 0);
+
+	//calculating the components of the gradient
+	for(size_t j = 0; j < functiongradient.size(); j++)
+		//if enough monomials were calculated already, they can be taken directly
+		if(_structure[i][j].size() > bfp.size()) 
+			//walking over every monomial and calculate the contribution to the gradient vector
+			for(size_t k = 1; k < bfp.size(); k++)
+				functiongradient[j] += bfp[k] * _structure[i][j][k];
+		else
+		{
+			//extend @_structure and calculate the gradient
+			extendStructure(i, j, bfp.size(), pts, order);
+			for(size_t k = 1; k < _structure[i][j].size(); k++)
+				functiongradient[j] += bfp[k] * _structure[i][j][k];
+		}
+	//normalizing the gradient
+	double tmp = LinAlg::getAbs(functiongradient);
+	
+	//in order to avoid NaN's, the gradient is only normalized if it isn't a zerovector, else it's normalized vector is the vector itself
+	if(tmp != 0)
+		for(size_t i = 0; i < functiongradient.size(); i++)
+			functiongradient[i] /= tmp;
+		
+	return functiongradient;
+}
+
+/**
+ * This function calculates all gradient vectors
+ * @bfp: fit parameters
+ * @pts: storage of the anchor points and powers
+ * @order: order of the polynomial function
+ * @result: list of gradient vectors evaluated at each anchor point
+ */
+const vector<vector<double>> GradCalc::getAllGradVectors(const std::vector<double>& bfp, Professor::ParamPoints& pts, const int order){
+	vector<vector<double>> result;
+	//calculate each gradient vector
+	for(size_t i = 0; i < _structure.size(); i++)
+		result.push_back(getGradVector(i, bfp, pts, order));
+	return result;	
+}
diff -uNr Professor-2.2.2/src/HyperCubeIpol.cc Professor-2.2.2_mod/src/HyperCubeIpol.cc
--- Professor-2.2.2/src/HyperCubeIpol.cc	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/src/HyperCubeIpol.cc	2017-11-27 16:14:37.868370000 +0100
@@ -0,0 +1,204 @@
+#include "Professor/HyperCubeIpol.h"
+
+/**
+ * This function rescales an anchor point on a [0,1]-interval
+ * @i: index of the anchor point
+ * @pts: set of all points
+ * @result: rescaled vector
+ * @min, @max: component-wise smallest/biggest value in @pts
+ */
+vector<double> rescale(const size_t i, const vector<vector<double>>& pts){
+	
+	vector<double> result;
+	double min = numeric_limits<double>::infinity(), max = -numeric_limits<double>::infinity();
+	
+	//search the smallest/biggest value of each component
+	for(size_t j = 0; j < pts[0].size(); j++)
+	{
+		for(size_t k = 0; k < pts.size(); k++)
+		{
+			if(pts[k][j] < min)
+				min = pts[k][j];
+			if(pts[k][j] > max)
+				max = pts[k][j];
+		}
+		//set the rescaled component
+		result.push_back((pts[i][j] - min) / (max - min));
+		min = numeric_limits<double>::infinity();
+		max = -numeric_limits<double>::infinity();
+	}
+	return result;	
+}
+
+/**
+ * Constructor
+ */
+HyperCubeIpol::HyperCubeIpol(){}
+
+/**
+ * This function searches the anchor points that form a hypercube around a given anchor point
+ * @i: index of the anchor point around which the hypercube should be constructed
+ * @pts: set of all anchor points
+ * @center: @i-th anchor point
+ * @result: list of indices of the anchor points that form the hypercube
+ * @distances: list of the currently closest points that form a hypercube
+ * @bin: helper to find the right comparisons of @distances
+ */
+void HyperCubeIpol::buildHyperCube(const size_t i, const vector<vector<double>>& pts){
+  
+	//setting up @center and the resultvector
+	vector<double> center = pts[i];
+	vector<size_t> result;
+	
+	//if a point isn't set, it's value is number of anchor points + 1, so that these points can be found and won't be used for further calculations
+	//this is important for points at the border of the sampleregion
+	result.assign(pow(2., pts[0].size()), pts.size());
+	
+	//The same procedure as before is done for the distances, so that a check is possible if the smallest possible hypercube cann be constructed. Therefore it's initial values are set to infinity.
+	vector<double> distances;
+	distances.assign(pow(2., pts[0].size()), numeric_limits<double>::infinity());	
+	size_t bin = 0;
+	
+	for(size_t j = 0; j < pts.size(); j++)
+		//if a point matches @center, it will be skipped
+		if(i == j)
+			continue;
+		else
+		{
+			//component wise check, if the components are bigger than the center point
+			for(size_t k = 0; k < pts[0].size(); k++)
+				if(center[k] >= pts[j][k])
+					//All 'if' checks are binary questions, therefore a binary representation as summary can be found.
+					//@bin is a value that can directly connect to the overall situation of the test point due to its value
+					bin += pow(2., k);
+
+			//check up, if the new trial point is closer than the stored one in the category specified by @bin
+			if(LinAlg::getDistanceOfVectors(center, pts[j]) < distances[bin])
+			{
+				//if closer than set it as new point
+				distances[bin] = LinAlg::getDistanceOfVectors(center, pts[j]);
+				result[bin] = j;				
+			}	
+			bin = 0;
+		}
+	//store the result
+	_hypercubes[i] = result;
+	_hypercubes[i].push_back(i);
+}
+  
+/**
+ * This function calculates a list of indices referring to the hypercube surrounding the point with index @i
+ * @i: number of the point around which a hypercube should be constructed
+ * @pts: set of all anchor points
+ */
+const vector<size_t>& HyperCubeIpol::gethypercube(const size_t i, const vector<vector<double>>& pts){
+	
+	//If the size of the hypercubes does not fit, it will be resized.
+	//This construction is meant as initializer of @_hypercubes
+	if(_hypercubes.size() != pts.size())
+		_hypercubes.resize(pts.size());
+		
+	//if the hypercube is already calculated, return it
+	if(!_hypercubes[i].empty())
+		return _hypercubes[i];
+	
+	//build the hypercube and return it
+	buildHyperCube(i, pts);	
+	return _hypercubes[i];
+}
+
+/**
+ * This function is a getter of the fit parameters of each anchor point
+ * @pts: set of all anchor points
+ * @ptvals: bin value of @pts
+ */
+const vector<vector<double>>& HyperCubeIpol::getAllFitParams(const vector<vector<double>>& pts, const vector<double>& ptvals){
+	//setup
+	if(_fitparams.empty())
+		_fitparams.resize(_hypercubes.size());
+		
+	//if fit parameters are not calculated yet, they are calculated
+	for(size_t i = 0; i < _fitparams.size(); i++)
+		if(_fitparams[i].empty())
+			calcFitParams(i, pts, ptvals);
+	return _fitparams;
+}
+
+/**
+ * This function is a getter of the fit parameters of a certain anchor point
+ * @i: number of the anchor point
+ * @pts: set of all anchor points
+ * @ptvals: bin value of @pts
+ */
+const vector<double>& HyperCubeIpol::getFitParams(const size_t i, const vector<vector<double>>& pts, const vector<double>& ptvals){
+
+	//setup
+	if(_hypercubes.empty())
+		for(size_t j = 0; j < pts.size(); j++)
+			gethypercube(j, pts);
+	if(_fitparams.empty())
+		_fitparams.resize(_hypercubes.size());
+
+	//if the fit parameters are not calculated yet, they are calculated
+	if(_fitparams[i].empty())
+		calcFitParams(i, pts, ptvals);
+
+	return _fitparams[i];
+}
+
+/**
+ * This function calculates the fit parameters for a certain anchor point
+ * @i: number of the anchor point
+ * @pts: set of all anchor points
+ * @ptvals: bin value of @pts
+ * @tmp_points: storage of the anchor points that form the hypercube
+ * @tmp_points_scaled: storage of the rescaled anchor points that for the hypercube
+ * @tmp_ptvals: storage of the bin values of @tmp_points
+ * @qrh: helper for performing the fit
+ * @tmp_pts: helper object to pass the necessary information to @qrh
+ * @a: vector that indicates RR-constrained parameters
+ */
+void HyperCubeIpol::calcFitParams(const size_t i, const vector<vector<double>>& pts, const vector<double>& ptvals){
+	
+	vector<vector<double>> tmp_points, tmp_points_scaled;
+	vector<double> tmp_ptvals;
+	QRHandler qrh;
+	
+	//store the values
+	for(size_t j = 0; j < gethypercube(i, pts).size(); j++)
+		if(gethypercube(i, pts)[j] < pts.size())
+		{
+			tmp_points.push_back(pts[gethypercube(i, pts)[j]]);
+			tmp_points_scaled.push_back(rescale(gethypercube(i, pts)[j], pts));
+			tmp_ptvals.push_back(ptvals[gethypercube(i, pts)[j]]);
+		}
+	Professor::ParamPoints tmp_pts(tmp_points);	
+	tmp_pts.setpointsScaled(tmp_points_scaled);
+	
+	//perform the QR-decomposition
+	qrh.init(tmp_pts, tmp_ptvals);
+	for(size_t j = 0; j < pts[0].size(); j++)
+		qrh.iterate(tmp_pts);
+	
+	//check for RR-constrains
+	vector<double> a;
+	a.resize(pts[0].size() + 1);
+	LinAlg::collinearity(a, qrh.getR(), qrh.getB(), 10e-10, 10e-10);
+		
+	//get unscaled fit parameters
+	_fitparams[i] = LinAlg::getBestFitParameters(qrh.getR(), a, qrh.getBprime());
+		
+	for(size_t j = 0; j < _fitparams[i].size(); j++)
+		_fitparams[i][j] *= LinAlg::getAbs(qrh.getB()) / LinAlg::getAbs(LinAlg::getCol(qrh.getM(), j));
+}
+
+
+
+
+
+
+
+
+
+
+
diff -uNr Professor-2.2.2/src/Ipol.cc Professor-2.2.2_mod/src/Ipol.cc
--- Professor-2.2.2/src/Ipol.cc	2017-11-13 15:32:46.000000000 +0100
+++ Professor-2.2.2_mod/src/Ipol.cc	2018-01-05 15:14:51.651959933 +0100
@@ -288,6 +288,179 @@
 
   ///////////////////////////////////////////////////////
 
+/**
+ * Constructor for adaptive interpolation
+ * @pts: Anchor points
+ * @ptvlas: Response of each point in @pts
+ * @pterrs: Uncertainty of each response in @ptvals
+ * @num_ipol: Index of the bin, used for output
+ * @doipol: Boolean flag. If true then an interpolation will be calculated, otherwise the uncertainty of the fit parameters is performed
+ * @order: If a fit function is already calculated, the order of the polynomial is passed to improve the uncertainty calculation speed
+ * @fitparams: If a fit function is already calculated, this parameter represents the fit parameters for an uncertainty calculation
+ * @configfile: Path to a file that contains additional configuration information
+ */
+Ipol::Ipol(ParamPoints& pts, const std::vector<double>& ptvals, const vector<double>& pterrs, const int num_ipol, const string histname, const bool doipol, const int order, const std::vector<double>& fitparams, const string configfile){
+	
+	//rescale parameter ranges
+	pts.rescale();
+	
+	//either perform an interpolation or an uncertainty calculation
+	if(doipol)
+		calcipol(pts, ptvals, pterrs, num_ipol, configfile, histname);
+	else
+		calcerr(pts, pterrs, order, fitparams, num_ipol, histname);
+	
+	//clean memory
+	pts.clearAll();
+}
+    
+/**
+ * This function calculates the interpolation.
+ * @pts: Anchor points
+ * @ptvlas: Response of each point in @pts
+ * @pterrs: Uncertainty of each response in @ptvals
+ * @num_ipol: Index of the bin, used for output
+ * @configfile: Path to a file that contains additional configuration information
+ * @ch: Object that loads and stores the infromation in the configuration file
+ * @oh: Object that handles the output
+ * @fh: Object that handles the interpolation
+ * @qp: Structure that stores the last couple quality parameters and tracks the currently best iteration
+ */ 
+void Ipol::calcipol(ParamPoints& pts, const std::vector<double>& ptvals, const std::vector<double>& pterrs, const int num_ipol, const std::string configfile, const std::string histname) {
+
+	cout << "start with bin " << num_ipol << " in " << histname << endl;
+		
+	//Crate and initialize objects
+	ConfigHandler* ch = new ConfigHandler(configfile);
+	OutputHandler oh(pts, ch->getOutDotFlag(), ch->getSummaryFlag(), num_ipol);
+	FitHandler fh;	
+	fh.startBin(pts, ptvals, pterrs, ch->getThresholdFit(), ch->getKappa());
+	qualityparams qp;
+	qp.bestiteration = fh.getIterationCounter();
+	qp.bestF = fh.getChi2();
+	qp.Fvalues.push_back(fh.getChi2());
+	
+	//calculate the new normal vectors of the data
+	pts.setGradients(ptvals);
+	cout << "start iterating for bin " << num_ipol << endl;
+	//continuously iterate while a fit becomes better with more iterations
+	while(iterate(fh, pts, ch, qp)){}
+
+	cout << "fit complete for bin " << num_ipol << " in " << histname << endl;
+	
+	//recalculate the best iteration
+	fh.setToIteration(pts, ptvals, pterrs, num_ipol, ch->getThresholdFit(), ch->getKappa(), qp.bestiteration);			
+	
+	//write out the result
+	oh.writeBinResult(num_ipol, pts, fh);
+	if(ch->getOutDotFlag())
+		oh.writeDotProduct(num_ipol, pts, fh);
+	if(ch->getSummaryFlag())
+		oh.writeSummary(fh, pts);
+		
+	delete(ch);
+	qp.Fvalues.clear();
+	//set parameters used by Professor
+	setparams(pts, fh);
+}
+
+/**
+ * This function performs an iteration of the adaptive interpolation
+ * @fh: Object that handles the interpolation
+ * @pts: Anchor points
+ * @ch: Object that loads and stores the infromation in the configuration file
+ * @qp: Structure that stores the last couple quality parameters and tracks the currently best iteration
+ * @mean: Storage of the mean of the F-values stored in @qp.
+ */
+const bool Ipol::iterate(FitHandler& fh, ParamPoints& pts, ConfigHandler* const ch, qualityparams& qp) const{
+	//iterate
+	fh.nextStep(pts, ch->getThresholdFit(), ch->getKappa());
+	
+	//store quality parameter
+	qp.Fvalues.push_back(fh.getChi2() * (1 - fh.getDsmooth(pts)) / (1 + fh.getDsmooth(pts)));
+	
+	//if enough iterations were made, the convergence check will be performed
+	if(qp.Fvalues.size() >= ch->getChi2Mean())
+	{
+		double mean = 0.;
+		//calculate the mean of @qp.Fvalues
+		for(size_t i = 0; i < qp.Fvalues.size(); i++)
+			mean += qp.Fvalues[i];
+		mean /= qp.Fvalues.size();
+
+		//if the current value is equal or worse the sliding mean, the loop ends
+		if(qp.Fvalues[qp.Fvalues.size() - 1] >= mean)
+			return false;
+
+		//delete the first entry in @qp.Fvalues -> list length remains constant
+		qp.Fvalues.erase(qp.Fvalues.begin());
+	}
+
+	//store 
+	if(qp.Fvalues.back() < qp.bestF)
+	{
+		qp.bestF = qp.Fvalues.back();
+		qp.bestiteration = fh.getIterationCounter();
+	}
+
+	return true;
+}
+
+/**
+ * This function sets the member parameters such that Professor can work without additional interfaces
+ * @pts: Anchor points
+ * @fh: Object that handles the interpolation
+ * @match_index: List of indices; Used for re-ordering the fit parameters to fit Professor 2.2.1's order
+ */
+void Ipol::setparams(ParamPoints& pts, FitHandler& fh){
+	
+	_dim = pts.dim();	
+	_minPV = pts.ptmins();
+	_maxPV = pts.ptmaxs();
+	_name = "";
+	_order = fh.getMaxPower();
+	
+	//sort fit parameters
+	std::vector<int> match_index = sort_strucs(pts);
+	fh.sortFitParams(match_index);	
+	match_index.clear();
+
+	_coeffs = fh.getFitParams();
+	_structure = mkStructure(_dim, _order);
+}
+
+/**
+ * This function performs a re-ordering of the order of the fit parameters in order to fit Professor 2.2.1's order.
+ * @pts: Anchor points
+ * @profstruc: The structure of the fit parameters of Professor 2.2.1
+ * @result: List of mapping numbers for later usage
+ */
+const std::vector<int> Ipol::sort_strucs(ParamPoints& pts) const{
+
+	//calculate the Professor 2.2.1 structure
+	std::vector<std::vector<int>> profstruc = mkStructure(_dim, _order);
+	std::vector<int> result;
+
+	//walk over both list, if there is a match, write down the number in @result
+	for(size_t pi = 0; pi < profstruc.size(); pi++)
+		for(size_t i = 0; i < pts.getPower(_order).size(); i++)
+			if(pts.getPower(_order)[i] == profstruc[pi])
+				result.push_back(i);
+	return result;	
+}
+
+void Ipol::calcerr(ParamPoints& pts, const std::vector<double>& pterrs, const int order, const std::vector<double>& fitparams, const int num_ipol, const string histname){
+
+	std::cout << "calculating error for bin " << num_ipol << " in " << histname << endl;
+		
+	FitHandler fh(fitparams, pterrs, pts, order, num_ipol, histname);
+	setparams(pts, fh);
+	
+	cout << "error calculation complete for bin " << num_ipol << " in " << histname << endl;
+}
+
+  ///////////////////////////////////////////////////////
+
 
 
   string Ipol::toString(const string& name) const {
diff -uNr Professor-2.2.2/src/LinAlg.cc Professor-2.2.2_mod/src/LinAlg.cc
--- Professor-2.2.2/src/LinAlg.cc	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/src/LinAlg.cc	2017-11-28 12:45:00.731326000 +0100
@@ -0,0 +1,209 @@
+#include "Professor/LinAlg.h"
+
+using namespace std;
+
+/**
+ * This function returns a column of a matrix
+ * @mat: matrix, out of which the column will be extracted
+ * @j: number of column
+ * @tmp: column that will be returned
+ */
+const vector<double> LinAlg::getCol(const vector<vector<double>>& mat, const size_t j){
+	vector<double> tmp;
+	for(size_t i = 0; i < mat.size(); i++)
+		tmp.push_back(mat[i][j]);
+	return tmp;
+}
+
+/**
+ * This function delivers the absolut value of a vector
+ * @vec: vector of interest
+ * @abs: absolut value
+ */
+const double LinAlg::getAbs(const vector<double>& vec){
+	double abs = 0.;
+	//summing up the sqaure of all components of the vector
+	for(size_t i = 0; i < vec.size(); i++)
+		abs += vec[i] * vec[i];
+	//return the sqrt of the sum
+	return sqrt(abs);
+}
+
+/**
+ * This function transposes a given matrix
+ * @mat: matrix, that will be transposed
+ * @tmp: temporary storage of the transposed matrix
+ */
+const vector<vector<double>> LinAlg::transpose(const vector<vector<double>>& mat){
+	vector<vector<double>> tmp;
+	
+	//setting @tmp's size to the size of @mat
+	tmp.resize(mat[0].size());
+	for(size_t i = 0; i < tmp.size(); i++)
+		tmp[i].resize(mat.size());
+	//transposing by switching the according indices
+	for(size_t i = 0; i < mat.size(); i++)
+		for(size_t j = 0; j < mat[0].size(); j++)
+			tmp[j][i] = mat[i][j];
+	return tmp;
+}
+
+/**
+ * This function multiplies a matrix and a vector
+ * @mat: matrix of the product
+ * @vec: vector of the product
+ * @result: returned vector, represents the product of @mat and @vec
+ * @tmp: helper of summing up a row of @mat and the components of @vec
+ */
+const vector<double> LinAlg::multMatVec(const vector<vector<double>>& mat, const vector<double>& vec){
+
+		vector<double> result;
+		
+		//setting @result's size to the number of rows in @mat
+		result.resize(mat.size());
+		double tmp = 0;
+
+		//walking over every row of @mat
+		for(size_t i = 0; i < mat.size(); i++)
+		{
+			//Walking over every column of @mat at a given row and walking over every component of @vec. The product is added to @tmp
+			for(size_t j = 0; j < vec.size(); j++)
+				tmp += mat[i][j] * vec[j];
+
+			//the sum is assigned to one component of the result and tmp is resetted
+			result[i] = tmp;
+			tmp = 0;
+		}
+		return result;
+}
+
+/**
+ * This function normalizes a vector. If the length of the vector is 0, the norm will be the vector itself in order to prevent nan's.
+ * @vec: vector, that will be normalized
+ * @abs: absolute value of the vector
+ * @result: if the length is != 0, the normalized vector will be stored in this variable
+ */
+const vector<double> LinAlg::normalizeVec(const vector<double>& vec){
+
+	//calculate the absolute value of @vec
+	const double abs = getAbs(vec);
+	
+	//if the length of @vec is != 0, it will be normalized, else the vector itself will be returned 
+	if(abs != 0)
+	{
+		vector<double> result;
+		result.resize(vec.size());
+
+		//calculating the normalized components of the vector
+		for(size_t i = 0; i < vec.size(); i++)
+			result[i] = vec[i] / abs; 
+			
+		return result;
+	}
+	else
+		return vec;
+}
+
+/**
+ * This function calculates the distance between two vectors
+ * @a, @b: vectors of interest
+ */
+const double LinAlg::getDistanceOfVectors(vector<double> a, const vector<double>& b){
+
+	//calculate the difference componentwise
+	for(size_t i = 0; i < a.size(); i++)
+		a[i] = a[i] - b[i];
+		
+	//return its absolut value
+	return getAbs(a);
+}
+
+/**
+ * This function delivers the dotproduct of two vectors.
+ * The special cases in this function are dotproduct with at least one zerovector. This causes a problem
+ * because two vectors are exactly the same if they are zerovectors. This is used as a part of the convergence criteria.
+ * In order to avoid this, the dotproduct of two zerovectors is defined as 1.
+ * Furthermore, if only one of those vectors is a zerovector, this may causes a similar problem.
+ * @a, @b: vectors for the dotproduct
+ * @result: result of the dotproduct
+ */
+const double LinAlg::dotProduct(const vector<double>& a, const vector<double>& b){
+	
+	//the case of both vectors are zerovectors is handled by explicit definition that the dotproduct of those (normalized) vectors is 1
+	if(getAbs(a) == 0. && getAbs(b) == 0.)
+		return 1.;
+		
+	double result = 0;
+	
+	//summing up the product componentwise
+	for(size_t i = 0; i < a.size(); i++)
+		result += a[i] * b[i];
+	return result;
+}
+
+
+/**
+ * This function solves a problem of the type A*x=b and finds the values of the vector x.
+ * x is passed to the function since previously set fit parameters are skipped in this function.
+ * Every parameter that is left to the estimation of its value is given as a nan.
+ * @a: matrix A
+ * @x: vector of parameters to fit
+ * @b: vector b
+ * @result: resulting parameters
+ */
+const vector<double> LinAlg::getBestFitParameters(const vector<vector<double>>& a, const vector<double>& x, vector<double> b){
+
+	//setting the size of @result
+	vector<double> result;
+	result.resize(x.size());
+
+	//starting at the bottom line, walking upwards and calculating the parameters
+	for(size_t i = x.size(); i > 0; i--)
+	{
+		//nan is an indicator in a component of @x for a component, that needs to be calculated
+		if(isnan(x[i - 1])){
+			//calculating a fit parameter
+			result[i - 1] = b[i - 1] / a[i - 1][i - 1];
+			
+			//forward the solution to every row above the regarded one
+			for(size_t j = 0; j < i - 1; j++)
+				b[j] -= a[j][i - 1] * result[i - 1];
+		}
+		else{
+			//If a values isn't nan, it was set by @LinAlg::collinearity(). It's value will be forwarded as above.
+			result[i - 1] = x[i - 1];
+			for(size_t j = 0; j < i - 1; j++)
+				b[j] -= a[j][i - 1] * result[i - 1];
+		}
+	}
+	return result;
+}
+
+/**
+ * This function checks, if the columns of the matrix M are collinear. If this is the case, then the diagonal terms of the matrix R would be very small.
+ * As a result of this, the corresponding fit parameters would become very big. Numerically, this leads to the situation that the fit function would only 
+ * depend on a few fit parameters. Therefore, those parameters are set in this function to avoid this behaiour.
+ * @a: Vector that is used to stores set fit parameters
+ * @r: Matrix R
+ * @b: Vector bprime
+ * @threshold: threshold for judging small values of @r on the diagonal
+ * @kappa: shift parameter in order to decrease the value of a fit parameter
+ * @riihat, @bihat: helper; Used for calculating the value of @a.
+ */
+void LinAlg::collinearity(vector<double>& a, const vector<vector<double>>& r, const vector<double>& b, const double threshold, const double kappa){
+	
+	//checking for RR constraints
+	for(size_t i = 0; i < a.size(); i++)
+	{
+		a[i] = nan("1");
+		//check if the value in @r is small
+		if(fabs(r[i][i]) < threshold)
+		{
+			//Setting the helpervariables for the creation of a smaller @a than one would get if the fit would run normally.
+			//The shift has it's source in @kappa and the according term of @_d.
+			const double riihat = sqrt(r[i][i] * r[i][i] + kappa);
+			const double bihat = (r[i][i] / riihat) * b[i];
+			a[i] = bihat / riihat;
+		}
+	}
+}
diff -uNr Professor-2.2.2/src/OutputHandler.cc Professor-2.2.2_mod/src/OutputHandler.cc
--- Professor-2.2.2/src/OutputHandler.cc	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/src/OutputHandler.cc	2017-12-05 13:52:18.576401000 +0100
@@ -0,0 +1,156 @@
+#include "Professor/OutputHandler.h"
+
+/**
+ * Constructor
+ */
+OutputHandler::OutputHandler(){}
+
+/**
+ * Constructor
+ * Here, the sizes of the vectors that will later contain fitparameters etc. will be set. Additionally, the distances and centers will be calculated
+ * @pts: Storage of the anchor points
+ * @outdotflag: Flag for writing dotproducts to file
+ * @summaryflag: Flag for writing additional summaries to file
+ * @num_ipol: Bin number
+ */
+OutputHandler::OutputHandler(const Professor::ParamPoints& pts, const bool outdotflag, const bool summaryflag, const size_t& num_ipol){	
+	//if the dotproduct-summary should be written, the distances are calculated
+	if(outdotflag)
+		setDistances(pts);
+	//if the summary should be written, the file will be created
+	if(summaryflag && (num_ipol == 0))
+		setupSummary();
+}	
+
+/**
+ * This function calculates the distances between the anchors points
+ * @pts: Storage of the anchor points
+ * @skips: No distances between an anchor point and itself is calculated, so the index shift needs is stored in this variable
+ */
+void OutputHandler::setDistances(const Professor::ParamPoints& pts){
+
+	//Resizing the @_distances vectors. No distances between an anchor point and itself will be calculated, therefore the size is modified accordingly.
+	_distances.resize(pts.numPoints() * pts.numPoints() - pts.numPoints());
+	
+	for(size_t i = 0; i < pts.numPoints(); i++)
+	{		
+		size_t skips = 0;
+		//compare every point with every other
+		for(size_t j = 0; j < pts.numPoints(); j++)
+			//if both points are the same, the iteration is skipped
+			if(i == j)
+				skips--;				
+			else
+				//calculate the distance between the vectors and store them
+				_distances[i * pts.numPoints() - i - 1 + j + skips] = LinAlg::getDistanceOfVectors(pts.pointScaled(i), pts.pointScaled(j));
+	}
+}
+
+/**
+ * This function creates the summary file and writes its header
+ * @outsummary: Provides the output to file functionality
+ */
+void OutputHandler::setupSummary() const{	
+	//set up the file and write the header
+	ofstream outsummary;
+	outsummary.open("summary", ofstream::out | ofstream::app);
+	outsummary << "Chi^2\tChi2^2,red\tIterations\tDsmooth" << endl;
+	outsummary.close();
+}
+
+/**
+ * This function writes the result of the fit of a bin to the terminal
+ * @num_ipol: Bin number
+ * @pts: Storage of the anchor points
+ * @fh: Handler of the fit
+ */
+void OutputHandler::writeBinResult(const size_t num_ipol, Professor::ParamPoints& pts, FitHandler& fh) const{
+	cout << endl << "Result for bin " << num_ipol << ":" << endl;
+
+	//the indices of the constrained monomials are printed to the terminal
+	cout << "RR constraint:\t";
+	for(size_t i = 0; i < fh.getNumFitParams(); i++)
+		if(!std::isnan(fh.get_a()[i]))
+			cout << i << "\t";
+	cout << endl;
+	
+	//write further summary variables
+	cout << "Dsmooth:\t\t" << fh.getDsmooth(pts) << endl;
+	cout << "chi2:\t\t\t" << fh.getChi2() << endl;
+	cout << "iterationcounter:\t" << fh.getIterationCounter() << endl;
+	cout << "max. power:\t\t" << fh.getMaxPower() << endl;
+	cout << "-------------------------" << endl;	
+}
+
+/**
+ * This function writes the dotproduct-summary
+ * @num_ipol: Bin number
+ * @pts: Storage of the anchor points
+ * @fh: Handles the fit
+ * @outdot: Provides the output to file functionality
+ * @rhdot, @fhdot: Stores the dot products of the reference data and the fit at every anchor point
+ */
+void OutputHandler::writeDotProduct(const size_t num_ipol, Professor::ParamPoints& pts, FitHandler& fh) const{
+	//set up the output
+	ofstream outdot;
+	outdot.open(("dotproduct" + to_string(num_ipol)).c_str());
+	
+	//calculate all dot products
+	vector<double> rhdot = pts.getAllGradDotProducts(), fhdot = fh.getAllGradDotProducts(pts);
+	
+	//write some summary parameters
+	outdot << fh.getDsmooth(pts) << "\t" << fh.getChi2() << "\t" << fh.getIterationCounter() << endl;
+		
+	//write the dot products of the reference data, the fit and the distances between the anchor points used for the dot product
+	for(size_t k = 0; k < rhdot.size(); k++)
+		outdot << rhdot[k] << "\t" << fhdot[k] << "\t" << _distances[k] << "\t";
+	outdot << endl;
+						
+	outdot.close();
+}
+	
+/**
+ * This function writes a summary of a fit to the summary file
+ * @fh: Handles the fit
+ * @pts: Storage of the anchor points
+ * @outsummary: Provides the output to file functionality
+ */
+void OutputHandler::writeSummary(FitHandler& fh, Professor::ParamPoints& pts) const{
+	//open the file and continue writing at the end
+	ofstream outsummary;
+	outsummary.open("summary", ofstream::out | ofstream::app);
+	//write out the resulting Chi^2, the number of iterations needed and the smoothness
+	outsummary << fh.getChi2() << "\t" << fh.getIterationCounter() << "\t" << fh.getDsmooth(pts) << endl;
+	outsummary.close();
+}
+
+/**
+ * This function writes the covariance matrix of the fit parameters to file.
+ * @mat: Covariance matrix
+ * @num_ipol: Bin number
+ * @outcovmat: Provides the output to file functionality 
+ */
+void OutputHandler::writeCovMat(const MatrixXd& mat, const size_t num_ipol, const string histname) const{
+	//open the file
+	ofstream outcovmat;
+	if(histname[0] == '/')
+		outcovmat.open((histname.substr(1, histname.find("/", 1) - 1) + "_" + histname.substr(histname.find("/", 1) + 1) + "_" + to_string(num_ipol)).c_str());
+	else
+		outcovmat.open((histname + to_string(num_ipol)).c_str());
+	
+	//write the matrix
+	for(size_t row = 0; row < (size_t) mat.rows(); row++)
+	{
+		for(size_t col = 0; col < (size_t) mat.cols(); col++)
+			//if a matrix element would become +/- inf, the value is replaced by +/- maximum of double
+			if(mat(row, col) == std::numeric_limits<double>::infinity())
+				outcovmat << std::numeric_limits<double>::max() << " ";
+			else
+				if(-mat(row, col) == std::numeric_limits<double>::infinity())
+					outcovmat << -std::numeric_limits<double>::max() << " ";
+				else
+					outcovmat << mat(row, col) << " ";
+		outcovmat << "\n";
+	}
+	outcovmat.close();
+}
diff -uNr Professor-2.2.2/src/ParamPoints.cc Professor-2.2.2_mod/src/ParamPoints.cc
--- Professor-2.2.2/src/ParamPoints.cc	2017-11-13 15:32:46.000000000 +0100
+++ Professor-2.2.2_mod/src/ParamPoints.cc	2018-01-05 15:21:32.370897859 +0100
@@ -16,6 +16,7 @@
     // }
     _parampoints = ppoints;
     _locked = true;
+    _pow.setDim(dim());
   }
 
 
@@ -122,5 +123,71 @@
     }
   }
 
+  /////////////////////////////////////////////////////////////////////////////////////////
+	
+/**
+ * This function maps the parameter points @_parampoints on a [0,1]-hypercube and stores them in @_parampoints_scaled
+ * @diff: Temporary storage of the difference between the maximum and minimum in every dimension
+ */
+void ParamPoints::rescale(){
+	
+	//if the points were not calculated yet, do it
+	if(pointsScaled().empty())
+	{
+		//resize @_parampoints_scaled so that its values can be set easy
+		_parampoints_scaled.resize(numPoints());
+		for(size_t i = 0; i < numPoints(); i++)
+			_parampoints_scaled[i].resize(dim());
+		
+		//walk over every dimension and calculate the difference between the maximum and the minimum value
+		vector<double> diff;
+		for(size_t i = 0; i < dim(); i++)
+			diff.push_back(ptmaxs()[i] - ptmins()[i]);
+		
+		//walk over every parameter set dimension-wise and rescale it on a [0,1]-hypercube
+		for(size_t i = 0; i < numPoints(); i++)
+			for(size_t j = 0; j < dim(); j++)
+				_parampoints_scaled[i][j] = (points()[i][j] - ptmins()[j]) / diff[j];	
+	}		
+}
+
+/**
+ * This function empties all lists in the object
+ */
+void ParamPoints::clearAll(){
+	_parampoints.clear();
+	_parampoints_scaled.clear();
+	_gradients.clear();
+	_names.clear();
+	_pow.clearAll();
+}
 
+/**
+ * This function sets the gradient vectors of each anchor point
+ * @ptvals: Bin values
+ */
+void ParamPoints::setGradients(const vector<double> ptvals){
+	GradCalc gc;
+	HyperCubeIpol hci;
+	//walk over every anchor point and calculate the gradient vector
+	for(size_t i = 0; i < numPoints(); i++)
+		_gradients.push_back(gc.getGradVector(i, hci.getFitParams(i, points(), ptvals), *this, 1));
+}
+
+/**
+ * This function calculates the dot product of every pair of gradient vectors of the anchor points
+ * @result: storage of the resulting values of the dotproducts
+ */
+const vector<double> ParamPoints::getAllGradDotProducts() const{
+	
+	vector<double> result;
+	
+	//walk over every possible combination of anchor points
+	for(size_t i = 0; i < _gradients.size(); i++)
+		for(size_t j = 0; j < _gradients.size(); j++)
+			//do not calculate the dotproduct if the points are the same
+			if(i != j)
+				result.push_back(LinAlg::dotProduct(_gradients[i], _gradients[j]));
+	return result;
+}
 }
diff -uNr Professor-2.2.2/src/Power.cc Professor-2.2.2_mod/src/Power.cc
--- Professor-2.2.2/src/Power.cc	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/src/Power.cc	2017-11-28 11:19:50.746616000 +0100
@@ -0,0 +1,52 @@
+#include "Professor/Power.h"
+
+/**
+ * This function calculates the list of powers up to a given order
+ * and adds them to the overall list @_powerlist
+ * @order: order up to which the powers will be calculated
+ * @tmp_power: temporary storage for the new list of powers until it will be added to @_powerlist
+ * @zero: list of 0's as the 0th order of powers
+ * @c: object that delivers the powers of the monomials
+ */
+void Power::setPowerOfOrder(const int order){
+	vector<vector<int>> tmp_power;
+
+	//setting the 0th order
+	const vector<int> zero(n, 0);
+	tmp_power.resize(1);
+	tmp_power[0] = zero;
+
+	//loop up to the maximum order
+	for (int i = 0; i <= order; ++i) 
+	{
+		//create a @Counter object of the order @i
+		Counter c(n, i);
+		
+		//calculate every combination of powers
+		//if they fit the order @i, they will be stored in @tmp_power
+		while (c.next(n-1)) 
+			if (c.sum() == i) 
+				tmp_power.push_back(c.data());     
+	}		
+	//saving the calculated list in @_powerlist at the position of the order		
+	_powerlist[order] = tmp_power;
+}
+
+/**
+ * This function is a getter for the list of powers of a given order.
+ * If the order isn't calculated yet, it will be calculated in this function.
+ * @order: order of the polynomial
+ */
+const vector<vector<int>> Power::getPowerOfOrder(const int order){
+
+	//the length of @_powerlist is equal to the highest order calculated
+	//if the requested order is higher, the size of @_powerlist will be adjusted
+	if(order > ((int) _powerlist.size()) - 1)
+		_powerlist.resize(order + 1);
+	
+	//if the order is not calculated yet, it will be calculated
+	if(_powerlist[order].empty())
+		setPowerOfOrder(order);
+
+	return _powerlist[order];
+}
diff -uNr Professor-2.2.2/src/QRHandler.cc Professor-2.2.2_mod/src/QRHandler.cc
--- Professor-2.2.2/src/QRHandler.cc	1970-01-01 01:00:00.000000000 +0100
+++ Professor-2.2.2_mod/src/QRHandler.cc	2017-11-29 11:10:58.239611000 +0100
@@ -0,0 +1,221 @@
+#include "Professor/QRHandler.h"
+ 
+/**
+ * This function initializes the object. Every necessary is getting calculated and the first iteration is performed.
+ * @pts: Storage of the anchor points and the powers
+ * @ptvals: Bin values of the anchor points
+ */
+void QRHandler::init(Professor::ParamPoints& pts, const vector<double>& ptvals){
+	_iterationcounter = 0;
+	_max = 0;
+	_b = ptvals;
+	_power = pts.getPower(0);
+	//setting up the matrices and iterate
+	iterate(pts);		
+}
+
+/**
+ * This function performs an iteration of the matrix M and forwards the new entries to Q and R
+ * @pts: Storage of the anchor points and the powers
+ */
+void QRHandler::iterateM(Professor::ParamPoints& pts){
+	
+	//set the size of @_m, if not done yet
+	if(_m.empty())
+		_m.resize(pts.numPoints());
+		
+	//if every power in @_power is already in use in @_m, new components of a higher power need to be calculated
+	if(_m[0].size() == _power.size())
+	{
+		//@_max is the order of the polynomial function. It will be increased and the new powers will be calculated
+		_max++;
+		_power = pts.getPower(_max);
+	}
+	//iterate
+	increaseM(pts);	
+	makeMprime();
+	expandQR();
+	_iterationcounter++;
+}
+
+/**
+ * This function updates @_bprime
+ */
+void QRHandler::iterateb(){
+	_bprime = LinAlg::normalizeVec(_b);
+	_bprime = LinAlg::multMatVec(LinAlg::transpose(_q), _bprime);
+}
+
+/**
+ * This function function performs an iteration of all matrices and vectors
+ * @pts: Storage of the anchor points and powers
+ * @walkthrough: Flag that decides, if @_bprime needs to be calculated at every iteration
+ */
+void QRHandler::iterate(Professor::ParamPoints& pts, const bool walkthrough){
+	iterateM(pts);
+	//If the flag is set, @_bprime will not get calculated.
+	if(!walkthrough)
+		iterateb();
+}
+
+/**
+ * This function initializes the matrices Q and R and sets the first values.
+ */
+const bool QRHandler::initQR(){
+	//set the sizes of @_q and @_r
+	if(_q.empty() || _r.empty())
+	{
+		_q.resize(_mprime.size());
+		_r.resize(_mprime[0].size());
+		
+		for(size_t k = 0; k < _q.size(); k++)
+			_q[k].resize(_mprime[0].size());
+		
+		for(size_t k = 0; k < _r.size(); k++)
+			_r[k].resize(_mprime[0].size());
+		
+		//calculating the first elements by using http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5342430&tag=1 on top of eq. 5
+		for(size_t k = 0; k < _q.size(); k++)
+			_q[k][0] = LinAlg::getCol(_mprime,0)[k] / LinAlg::getAbs(LinAlg::getCol(_mprime,0));
+
+		_r[0][0] = LinAlg::getAbs(LinAlg::getCol(_mprime,0));
+		return true;
+	}
+	return false;
+}
+
+/**
+ * This function updates the sizes of Q and R.
+ */
+void QRHandler::resizeQR(){
+	//after the first iteration, the sizes are adapted according to the current size of @_mprime 
+	_q.resize(_mprime.size());
+	_r.resize(_mprime[0].size());
+	for(size_t k = 0; k < _q.size(); k++)
+		_q[k].resize(_mprime[0].size());
+	for(size_t k = 0; k < _r.size(); k++)
+		_r[k].resize(_mprime[0].size());
+}
+
+/**
+ * This function builds the QR-decomposition or increase the matrices, if they already exist
+ * @tmp: Temporary storage for the increase of @_r
+ * @sum: Temporary storage for the increase of @_q
+ */
+void QRHandler::expandQR(){
+
+	//if @_q and @_r are not initialize yet, it will be done here and the function quits
+	if(initQR()) return;
+	//update the sizes of @_q and @_r
+	resizeQR();
+	const size_t iteration = _iterationcounter;
+	
+	//the following calculations add the new elements to @_q and @_r
+	double tmp;
+	for(size_t l = 0; l < iteration; l++)
+	{
+		tmp = 0;
+		for(size_t k = 0 ; k < _q.size(); k++)
+			tmp += _q[k][l] * _mprime[k][iteration];
+		_r[l][iteration] = tmp;
+	}
+	vector<double> sum;
+	sum.assign(_q.size(), 0);
+	for(size_t l = 0; l < sum.size(); l++)
+		for(size_t k = 0; k < iteration; k++)
+			sum[l] += _r[k][iteration] * _q[l][k];
+				
+	for(size_t k = 0; k < _q.size(); k++)
+		_q[k][iteration] = _mprime[k][iteration] - sum[k];
+
+	_r[iteration][iteration] = LinAlg::getAbs(LinAlg::getCol(_q, iteration));
+	tmp = LinAlg::getAbs(LinAlg::getCol(_q, iteration));
+	for(size_t k = 0; k < _q.size(); k++)
+	{
+		_q[k][iteration] /= tmp;
+		
+		//If @tmp is 0, the result would become nan. Setting it instead to 0 "stabilizes" the calculations.
+		if(std::isnan(_q[k][iteration])) 
+			_q[k][iteration] = 0;
+	}
+}
+
+/**
+ * This function normalizes every column of @_m by using the absolut value of the respective column.
+ * @abs: Absolut value of the column
+ */
+void QRHandler::makeMprime(){
+
+	//setting @_mprime to the same size as @_m
+	_mprime.resize(_m.size());
+	for(size_t i = 0; i < _mprime.size(); i++)
+		_mprime[i].resize(_m[i].size());
+
+	//getting the absolut value of the column
+	const double abs = LinAlg::getAbs(LinAlg::getCol(_m, _iterationcounter));
+
+	//setting the normalization
+	for(size_t i = 0; i < _m.size(); i++)
+		_mprime[i][_iterationcounter] = _m[i][_iterationcounter] / abs;
+}
+
+/**
+ * This function adds a new column to @_m
+ * @pts: Storage of the anchor points and powers
+ * @size: Old number of columns in @_m
+ * @tmp: Temporary storage of the product of the parts of a monomial
+ */
+void QRHandler::increaseM(Professor::ParamPoints& pts){
+
+	//set the size of @_m, if not done yet
+	if(_m.empty())
+		_m.resize(pts.numPoints());
+	
+	//adding a new column to @_m
+	size_t size = _m[0].size();
+	for(size_t i = 0; i < _m.size(); i++)
+		_m[i].resize(size + 1);
+
+	double tmp = 1;
+	//walking over every row of @_m
+	for(size_t j = 0; j < _m.size(); j++)
+	{	
+		//in every row the product of the values and the respective powers is calculated
+		for(size_t i = 0; i < pts.dim(); i++)
+			tmp *= pow(pts.pointScaled(j)[i], _power[_m[0].size() - 1][i]);
+			
+		//the new terms will be added to the last column in every row and @tmp is resetted
+		_m[j][size] = tmp;
+		tmp = 1;
+	}
+}
+
+/**
+ * This function sets the member variables to a certain iteration
+ * @order: Order of the polynomial function
+ * @pts: Storage of the anchor points and powers
+ * @numFitParams: Number of fit parameters
+ */
+void QRHandler::load(const int order, Professor::ParamPoints& pts, const size_t numFitParams){
+	_power = pts.getPower(order);
+	_max = order;
+	_iterationcounter = 0;
+	
+	//set the size of @_m, if not done yet
+	if(_m.empty())
+		_m.resize(pts.numPoints());
+	
+	//set up @_m
+	while(_m[0].size() < numFitParams)
+		iterate(pts, true);
+}
+
+/**
+ * This function empties all vectors in this object
+ */
+void QRHandler::reset(){
+	_m.clear();
+	_r.clear();
+	_q.clear();
+	_mprime.clear();
+}
Binary files Professor-2.2.2/test/testIpol and Professor-2.2.2_mod/test/testIpol differ
Binary files Professor-2.2.2/test/testParamPoints and Professor-2.2.2_mod/test/testParamPoints differ
